{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#codellm-devkit-a-python-library-for-seamless-interaction-with-codellms","title":"CodeLLM-Devkit: A Python library for seamless interaction with CodeLLMs","text":"<p>Codellm-devkit (CLDK) is a multilingual program analysis framework that bridges the gap between traditional static analysis tools and Large Language Models (LLMs) specialized for code (CodeLLMs). Codellm-devkit allows developers to streamline the process of transforming raw code into actionable insights by providing a unified interface for integrating outputs from various analysis tools and preparing them for effective use by CodeLLMs.</p> <p>Codellm-devkit simplifies the complex process of analyzing codebases that span multiple programming languages, making it easier to extract meaningful insights and drive LLM-based code analysis. <code>CLDK</code> achieves this through an open-source Python library that abstracts the intricacies of program analysis and LLM interactions. With this library, developer can streamline the process of transforming raw code into actionable insights by providing a unified interface for integrating outputs from various analysis tools and preparing them for effective use by CodeLLMs.</p> <p>The purpose of Codellm-devkit is to enable the development and experimentation of robust analysis pipelines that harness the power of both traditional program analysis tools and CodeLLMs. By providing a consistent and extensible framework, Codellm-devkit aims to reduce the friction associated with multi-language code analysis and ensure compatibility across different analysis tools and LLM platforms.</p> <p>Codellm-devkit is designed to integrate seamlessly with a variety of popular analysis tools, such as WALA, Tree-sitter, LLVM, and CodeQL, each implemented in different languages. Codellm-devkit acts as a crucial intermediary layer, enabling efficient and consistent communication between these tools and the CodeLLMs.</p> <p>Codellm-devkit is constantly evolving to include new tools and frameworks, ensuring it remains a versatile solution for code analysis and LLM integration.</p> <p>Codellm-devkit is:</p> <ul> <li>Unified: Provides a single framework for integrating multiple analysis tools and CodeLLMs, regardless of the programming languages involved.</li> <li>Extensible: Designed to support new analysis tools and LLM platforms, making it adaptable to the evolving landscape of code analysis.</li> <li>Streamlined: Simplifies the process of transforming raw code into structured, LLM-ready inputs, reducing the overhead typically associated with multi-language analysis.</li> </ul>"},{"location":"#architectural-and-design-overview","title":"Architectural and Design Overview","text":"<p>Below is a very high-level overview of the architectural of CLDK:</p> <pre><code>graph TD\nUser &lt;--&gt; A[CLDK]\n    A --&gt; 15[Retrieval \u2021]\n    A --&gt; 16[Prompting \u2021]\n    A[CLDK] &lt;--&gt; B[Languages]\n        B --&gt; C[Java, Python, Go \u2021, C \u2021, JavaScript \u2021, TypeScript \u2021, Rust \u2021]\n            C --&gt; D[Data Models]\n                D --&gt; 13{Pydantic}\n            13 --&gt; 7            \n            C --&gt; 7{backends}\n                7 &lt;--&gt; 9[WALA]\n                    9 &lt;--&gt; 14[Analysis]\n                7 &lt;--&gt; 10[Tree-sitter] \n                    10 &lt;--&gt; 14[Analysis]\n                7 &lt;--&gt; 11[LLVM \u2021]\n                    11 &lt;--&gt; 14[Analysis]\n                7 &lt;--&gt; 12[CodeQL \u2021]\n                    12 &lt;--&gt; 14[Analysis]\n\n\n\nX[\u2021 Yet to be implemented]\n</code></pre> <p>The user interacts by invoking the CLDK API. The CLDK API is responsible for handling the user requests and delegating them to the appropriate language-specific modules. </p> <p>Each language comprises of two key components: data models and backends.</p> <ol> <li> <p>Data Models: These are high level abstractions that represent the various language constructs and componentes in a structured format using pydantic. This confers a high degree of flexibility and extensibility to the models as well as allowing for easy accees of various data components via a simple dot notation. In addition, the data models are designed to be easily serializable and deserializable, making it easy to store and retrieve data from various sources.</p> </li> <li> <p>Analysis Backends: These are the components that are responsible for interfacing with the various program analysis tools. The core backends are Treesitter, Javaparse, WALA, LLVM, and CodeQL. The backends are responsible for handling the user requests and delegating them to the appropriate analysis tools. The analysis tools perfrom the requisite analysis and return the results to the user. The user merely calls one of several high-level API functions such as <code>get_method_body</code>, <code>get_method_signature</code>, <code>get_call_graph</code>, etc. and the backend takes care of the rest. </p> <p>Some langugages may have multiple backends. For example, Java has WALA, Javaparser, Treesitter, and CodeQL backends. The user has freedom to choose the backend that best suits their needs. </p> </li> </ol> <p>We are currently working on implementing the retrieval and prompting components. The retrieval component will be responsible for retrieving the relevant code snippets from the codebase for RAG usecases. The prompting component will be responsible for generating the prompts for the CodeLLMs using popular prompting frameworks such as <code>PDL</code>, <code>Guidance</code>, or <code>LMQL</code>. </p>"},{"location":"#contact","title":"Contact","text":"<p>For any questions, feedback, or suggestions, please contact the authors:</p> Name Email Rahul Krishna i.m.ralk@gmail.com Rangeet Pan rangeet.pan@ibm.com Saurabh Sihna sinhas@us.ibm.com"},{"location":"api_reference/","title":"API Reference","text":"<p>This page documents the API functionalities.</p>"},{"location":"api_reference/#models","title":"Models","text":""},{"location":"api_reference/#python","title":"Python","text":"<p>Models module</p> <p>Classes:</p> Name Description <code>PyBuildAttributes</code> <p>Handles all the project build tool (requirements.txt/poetry/setup.py) attributes</p> <code>PyConfig</code> <p>Application configuration information</p>"},{"location":"api_reference/#cldk.models.python.models.PyBuildAttributes","title":"<code>PyBuildAttributes</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Handles all the project build tool (requirements.txt/poetry/setup.py) attributes</p> Source code in <code>cldk/models/python/models.py</code> <pre><code>class PyBuildAttributes(BaseModel):\n    \"\"\"Handles all the project build tool (requirements.txt/poetry/setup.py) attributes\"\"\"\n</code></pre>"},{"location":"api_reference/#cldk.models.python.models.PyConfig","title":"<code>PyConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Application configuration information</p> Source code in <code>cldk/models/python/models.py</code> <pre><code>class PyConfig(BaseModel):\n    \"\"\"Application configuration information\"\"\"\n</code></pre>"},{"location":"api_reference/#java","title":"Java","text":"<p>Models module</p> <p>Classes:</p> Name Description <code>JField</code> <p>Represents a field in a Java class or interface.</p> <code>JCallableParameter</code> <p>Represents a parameter of a Java callable.</p> <code>JEnumConstant</code> <p>Represents a constant in an enumeration.</p> <code>JCallSite</code> <p>Represents a call site.</p> <code>JVariableDeclaration</code> <p>Represents a variable declaration.</p> <code>JCallable</code> <p>Represents a callable entity such as a method or constructor in Java.</p> <code>JType</code> <p>Represents a Java class or interface.</p> <code>JCompilationUnit</code> <p>Represents a compilation unit in Java.</p> <code>JMethodDetail</code> <p>Represents details about a method in a Java class.</p> <code>JGraphEdgesST</code> <p>Represents an edge in a graph structure for method dependencies.</p> <code>JApplication</code> <p>Represents a Java application.</p>"},{"location":"api_reference/#cldk.models.java.models.JField","title":"<code>JField</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a field in a Java class or interface.</p> <p>Attributes:</p> Name Type Description <code>comment</code> <code>str</code> <p>The comment associated with the field.</p> <code>name</code> <code>str</code> <p>The name of the field.</p> <code>type</code> <code>str</code> <p>The type of the field.</p> <code>start_line</code> <code>int</code> <p>The starting line number of the field in the source file.</p> <code>end_line</code> <code>int</code> <p>The ending line number of the field in the source file.</p> <code>variables</code> <code>List[str]</code> <p>The variables declared in the field.</p> <code>modifiers</code> <code>List[str]</code> <p>The modifiers applied to the field (e.g., public, static).</p> <code>annotations</code> <code>List[str]</code> <p>The annotations applied to the field.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JField(BaseModel):\n    \"\"\"Represents a field in a Java class or interface.\n\n    Attributes:\n        comment (str): The comment associated with the field.\n        name (str): The name of the field.\n        type (str): The type of the field.\n        start_line (int): The starting line number of the field in the source file.\n        end_line (int): The ending line number of the field in the source file.\n        variables (List[str]): The variables declared in the field.\n        modifiers (List[str]): The modifiers applied to the field (e.g., public, static).\n        annotations (List[str]): The annotations applied to the field.\n    \"\"\"\n\n    comment: str\n    type: str\n    start_line: int\n    end_line: int\n    variables: List[str]\n    modifiers: List[str]\n    annotations: List[str]\n</code></pre>"},{"location":"api_reference/#cldk.models.java.models.JCallableParameter","title":"<code>JCallableParameter</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a parameter of a Java callable.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the parameter.</p> <code>type</code> <code>str</code> <p>The type of the parameter.</p> <code>annotations</code> <code>List[str]</code> <p>The annotations applied to the parameter.</p> <code>modifiers</code> <code>List[str]</code> <p>The modifiers applied to the parameter.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JCallableParameter(BaseModel):\n    \"\"\"Represents a parameter of a Java callable.\n\n    Attributes:\n        name (str): The name of the parameter.\n        type (str): The type of the parameter.\n        annotations (List[str]): The annotations applied to the parameter.\n        modifiers (List[str]): The modifiers applied to the parameter.\n    \"\"\"\n\n    name: str | None\n    type: str\n    annotations: List[str]\n    modifiers: List[str]\n</code></pre>"},{"location":"api_reference/#cldk.models.java.models.JEnumConstant","title":"<code>JEnumConstant</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a constant in an enumeration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the enum constant.</p> <code>arguments</code> <code>List[str]</code> <p>The arguments associated with the enum constant.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JEnumConstant(BaseModel):\n    \"\"\"Represents a constant in an enumeration.\n\n    Attributes:\n        name (str): The name of the enum constant.\n        arguments (List[str]): The arguments associated with the enum constant.\n    \"\"\"\n\n    name: str\n    arguments: List[str]\n</code></pre>"},{"location":"api_reference/#cldk.models.java.models.JCallSite","title":"<code>JCallSite</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a call site.</p> <p>Attributes:</p> Name Type Description <code>method_name</code> <code>str</code> <p>The name of the method called at the call site.</p> <code>receiver_expr</code> <code>str</code> <p>Expression for the receiver of the method call.</p> <code>receiver_type</code> <code>str</code> <p>Name of type declaring the called method.</p> <code>argument_types</code> <code>List[str]</code> <p>Types of actual parameters for the call.</p> <code>return_type</code> <code>str</code> <p>Return type of the method call (resolved type of the method call expression; empty string if expression is unresolved).</p> <code>is_static_call</code> <code>bool</code> <p>Flag indicating whether the call is a static call.</p> <code>is_constructor_call</code> <code>bool</code> <p>Flag indicating whether the call is a constructor call.</p> <code>start_line</code> <code>int</code> <p>The starting line number of the call site.</p> <code>start_column</code> <code>int</code> <p>The starting column of the call site.</p> <code>end_line</code> <code>int</code> <p>The ending line number of the call site.</p> <code>end_column</code> <code>int</code> <p>The ending column of the call site.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JCallSite(BaseModel):\n    \"\"\"Represents a call site.\n\n    Attributes:\n        method_name (str): The name of the method called at the call site.\n        receiver_expr (str): Expression for the receiver of the method call.\n        receiver_type (str): Name of type declaring the called method.\n        argument_types (List[str]): Types of actual parameters for the call.\n        return_type (str): Return type of the method call (resolved type of the method call expression; empty string if expression is unresolved).\n        is_static_call (bool): Flag indicating whether the call is a static call.\n        is_constructor_call (bool): Flag indicating whether the call is a constructor call.\n        start_line (int): The starting line number of the call site.\n        start_column (int): The starting column of the call site.\n        end_line (int): The ending line number of the call site.\n        end_column (int): The ending column of the call site.\n    \"\"\"\n\n    method_name: str\n    receiver_expr: str = \"\"\n    receiver_type: str\n    argument_types: List[str]\n    return_type: str = \"\"\n    callee_signature: str = \"\"\n    is_static_call: bool | None = None\n    is_private: bool | None = None\n    is_public: bool | None = None\n    is_protected: bool | None = None\n    is_unspecified: bool | None = None\n    is_constructor_call: bool\n    start_line: int\n    start_column: int\n    end_line: int\n    end_column: int\n</code></pre>"},{"location":"api_reference/#cldk.models.java.models.JVariableDeclaration","title":"<code>JVariableDeclaration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a variable declaration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the variable.</p> <code>type</code> <code>str</code> <p>The type of the variable.</p> <code>initializer</code> <code>str</code> <p>The initialization expression (if present) for the variable declaration.</p> <code>start_line</code> <code>int</code> <p>The starting line number of the declaration.</p> <code>start_column</code> <code>int</code> <p>The starting column of the declaration.</p> <code>end_line</code> <code>int</code> <p>The ending line number of the declaration.</p> <code>end_column</code> <code>int</code> <p>The ending column of the declaration.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JVariableDeclaration(BaseModel):\n    \"\"\"Represents a variable declaration.\n\n    Attributes:\n        name (str): The name of the variable.\n        type (str): The type of the variable.\n        initializer (str): The initialization expression (if present) for the variable declaration.\n        start_line (int): The starting line number of the declaration.\n        start_column (int): The starting column of the declaration.\n        end_line (int): The ending line number of the declaration.\n        end_column (int): The ending column of the declaration.\n    \"\"\"\n\n    name: str\n    type: str\n    initializer: str\n    start_line: int\n    start_column: int\n    end_line: int\n    end_column: int\n</code></pre>"},{"location":"api_reference/#cldk.models.java.models.JCallable","title":"<code>JCallable</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a callable entity such as a method or constructor in Java.</p> <p>Attributes:</p> Name Type Description <code>signature</code> <code>str</code> <p>The signature of the callable.</p> <code>is_implicit</code> <code>bool</code> <p>A flag indicating whether the callable is implicit (e.g., a default constructor).</p> <code>is_constructor</code> <code>bool</code> <p>A flag indicating whether the callable is a constructor.</p> <code>comment</code> <code>str</code> <p>The comment associated with the callable.</p> <code>annotations</code> <code>List[str]</code> <p>The annotations applied to the callable.</p> <code>modifiers</code> <code>List[str]</code> <p>The modifiers applied to the callable (e.g., public, static).</p> <code>thrown_exceptions</code> <code>List[str]</code> <p>Exceptions declared via \"throws\".</p> <code>declaration</code> <code>str</code> <p>The declaration of the callable.</p> <code>parameters</code> <code>List[JCallableParameter]</code> <p>The parameters of the callable.</p> <code>return_type</code> <code>Optional[str]</code> <p>The return type of the callable. None if the callable does not return a value (e.g., a constructor).</p> <code>code</code> <code>str</code> <p>The code block of the callable.</p> <code>start_line</code> <code>int</code> <p>The starting line number of the callable in the source file.</p> <code>end_line</code> <code>int</code> <p>The ending line number of the callable in the source file.</p> <code>referenced_types</code> <code>List[str]</code> <p>The types referenced within the callable.</p> <code>accessed_fields</code> <code>List[str]</code> <p>Fields accessed in the callable.</p> <code>call_sites</code> <code>List[JCallSite]</code> <p>Call sites in the callable.</p> <code>variable_declarations</code> <code>List[JVariableDeclaration]</code> <p>Local variable declarations in the callable.</p> <code>cyclomatic_complexity</code> <code>int</code> <p>Cyclomatic complexity of the callable.</p> <p>Methods:</p> Name Description <code>__hash__</code> <p>Returns the hash value of the declaration.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JCallable(BaseModel):\n    \"\"\"Represents a callable entity such as a method or constructor in Java.\n\n    Attributes:\n        signature (str): The signature of the callable.\n        is_implicit (bool): A flag indicating whether the callable is implicit (e.g., a default constructor).\n        is_constructor (bool): A flag indicating whether the callable is a constructor.\n        comment (str): The comment associated with the callable.\n        annotations (List[str]): The annotations applied to the callable.\n        modifiers (List[str]): The modifiers applied to the callable (e.g., public, static).\n        thrown_exceptions (List[str]): Exceptions declared via \"throws\".\n        declaration (str): The declaration of the callable.\n        parameters (List[JCallableParameter]): The parameters of the callable.\n        return_type (Optional[str]): The return type of the callable. None if the callable does not return a value (e.g., a constructor).\n        code (str): The code block of the callable.\n        start_line (int): The starting line number of the callable in the source file.\n        end_line (int): The ending line number of the callable in the source file.\n        referenced_types (List[str]): The types referenced within the callable.\n        accessed_fields (List[str]): Fields accessed in the callable.\n        call_sites (List[JCallSite]): Call sites in the callable.\n        variable_declarations (List[JVariableDeclaration]): Local variable declarations in the callable.\n        cyclomatic_complexity (int): Cyclomatic complexity of the callable.\n    \"\"\"\n\n    signature: str\n    is_implicit: bool\n    is_constructor: bool\n    is_entry_point: bool = False\n    comment: str\n    annotations: List[str]\n    modifiers: List[str]\n    thrown_exceptions: List[str] = []\n    declaration: str\n    parameters: List[JCallableParameter]\n    return_type: Optional[str] = None  # Pythonic way to denote a nullable field\n    code: str\n    start_line: int\n    end_line: int\n    referenced_types: List[str]\n    accessed_fields: List[str]\n    call_sites: List[JCallSite]\n    variable_declarations: List[JVariableDeclaration]\n    cyclomatic_complexity: int | None\n\n    def __hash__(self):\n        \"\"\"\n        Returns the hash value of the declaration.\n        \"\"\"\n        return hash(self.declaration)\n\n    @model_validator(mode=\"after\")\n    def detect_entrypoint_method(self):\n        # check first if the class in which this method exists is concrete or not, by looking at the context var\n        if context_concrete_class.get():\n            # convert annotations to the form GET, POST even if they are @GET or @GET('/ID') etc.\n            annotations_cleaned = [match for annotation in self.annotations for match in re.findall(r\"@(.*?)(?:\\(|$)\", annotation)]\n\n            param_type_list = [val.type for val in self.parameters]\n            # check the param types against known servlet param types\n            if any(substring in string for substring in param_type_list for string in constants.ENTRY_POINT_METHOD_SERVLET_PARAM_TYPES):\n                # check if this method is over-riding (only methods that override doGet / doPost etc. will be flagged as first level entry points)\n                if \"Override\" in annotations_cleaned:\n                    self.is_entry_point = True\n                    return self\n\n            # now check the cleaned annotations against known javax ws annotations\n            if any(substring in string for substring in annotations_cleaned for string in constants.ENTRY_POINT_METHOD_JAVAX_WS_ANNOTATIONS):\n                self.is_entry_point = True\n                return self\n\n            # check the cleaned annotations against known spring rest method annotations\n            if any(substring in string for substring in annotations_cleaned for string in constants.ENTRY_POINT_METHOD_SPRING_ANNOTATIONS):\n                self.is_entry_point = True\n                return self\n        return self\n</code></pre>"},{"location":"api_reference/#cldk.models.java.models.JCallable.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash value of the declaration.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Returns the hash value of the declaration.\n    \"\"\"\n    return hash(self.declaration)\n</code></pre>"},{"location":"api_reference/#cldk.models.java.models.JType","title":"<code>JType</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a Java class or interface.</p> <p>Attributes:</p> Name Type Description <code>is_interface</code> <code>bool</code> <p>A flag indicating whether the object is an interface.</p> <code>is_inner_class</code> <code>bool</code> <p>A flag indicating whether the object is an inner class.</p> <code>is_local_class</code> <code>bool</code> <p>A flag indicating whether the object is a local class.</p> <code>is_nested_type</code> <code>bool</code> <p>A flag indicating whether the object is a nested type.</p> <code>is_class_or_interface_declaration</code> <code>bool</code> <p>A flag indicating whether the object is a class or interface declaration.</p> <code>is_enum_declaration</code> <code>bool</code> <p>A flag indicating whether the object is an enum declaration.</p> <code>is_annotation_declaration</code> <code>bool</code> <p>A flag indicating whether the object is an annotation declaration.</p> <code>is_record_declaration</code> <code>bool</code> <p>A flag indicating whether this object is a record declaration.</p> <code>is_concrete_class</code> <code>bool</code> <p>A flag indicating whether this is a concrete class.</p> <code>is_entry_point</code> <code>bool</code> <p>A flag indicating whether this is an entry point class.</p> <code>comment</code> <code>str</code> <p>The comment of the class or interface.</p> <code>extends_list</code> <code>List[str]</code> <p>The list of classes or interfaces that the object extends.</p> <code>implements_list</code> <code>List[str]</code> <p>The list of interfaces that the object implements.</p> <code>modifiers</code> <code>List[str]</code> <p>The list of modifiers of the object.</p> <code>annotations</code> <code>List[str]</code> <p>The list of annotations of the object.</p> <code>parent_type</code> <code>str</code> <p>The name of the parent class (if it exists).</p> <code>nested_type_declarations</code> <code>List[str]</code> <p>All the class declarations nested under this class.</p> <code>callable_declarations</code> <code>Dict[str, JCallable]</code> <p>The list of constructors and methods of the object.</p> <code>field_declarations</code> <code>List[JField]</code> <p>The list of fields of the object.</p> <code>enum_constants</code> <code>List[JEnumConstant]</code> <p>The list of enum constants in the object.</p> <p>Methods:</p> Name Description <code>check_concrete_class</code> <p>Detects if the class is concrete based on its properties.</p> <code>check_concrete_entry_point</code> <p>Detects if the class is entry point based on its properties.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JType(BaseModel):\n    \"\"\"Represents a Java class or interface.\n\n    Attributes:\n        is_interface (bool): A flag indicating whether the object is an interface.\n        is_inner_class (bool): A flag indicating whether the object is an inner class.\n        is_local_class (bool): A flag indicating whether the object is a local class.\n        is_nested_type (bool): A flag indicating whether the object is a nested type.\n        is_class_or_interface_declaration (bool): A flag indicating whether the object is a class or interface declaration.\n        is_enum_declaration (bool): A flag indicating whether the object is an enum declaration.\n        is_annotation_declaration (bool): A flag indicating whether the object is an annotation declaration.\n        is_record_declaration (bool): A flag indicating whether this object is a record declaration.\n        is_concrete_class (bool): A flag indicating whether this is a concrete class.\n        is_entry_point (bool): A flag indicating whether this is an entry point class.\n        comment (str): The comment of the class or interface.\n        extends_list (List[str]): The list of classes or interfaces that the object extends.\n        implements_list (List[str]): The list of interfaces that the object implements.\n        modifiers (List[str]): The list of modifiers of the object.\n        annotations (List[str]): The list of annotations of the object.\n        parent_type (str): The name of the parent class (if it exists).\n        nested_type_declarations (List[str]): All the class declarations nested under this class.\n        callable_declarations (Dict[str, JCallable]): The list of constructors and methods of the object.\n        field_declarations (List[JField]): The list of fields of the object.\n        enum_constants (List[JEnumConstant]): The list of enum constants in the object.\n    \"\"\"\n\n    is_interface: bool = False\n    is_inner_class: bool = False\n    is_local_class: bool = False\n    is_nested_type: bool = False\n    is_class_or_interface_declaration: bool = False\n    is_enum_declaration: bool = False\n    is_annotation_declaration: bool = False\n    is_record_declaration: bool = False\n    is_concrete_class: bool = False\n    is_entry_point: bool = False\n    comment: str\n    extends_list: List[str] = []\n    implements_list: List[str] = []\n    modifiers: List[str] = []\n    annotations: List[str] = []\n    parent_type: str\n    nested_type_declerations: List[str] = []\n    callable_declarations: Dict[str, JCallable] = {}\n    field_declarations: List[JField] = []\n    enum_constants: List[JEnumConstant] = []\n\n    # first get the data in raw form and check if the class is concrete or not, before any model validation is done\n    #   for this we assume if a class is not an interface or abstract it is concrete\n    #       for abstract classes we will check the modifiers\n    @model_validator(mode=\"before\")\n    def check_concrete_class(cls, values):\n        \"\"\"Detects if the class is concrete based on its properties.\"\"\"\n        values[\"is_concrete_class\"] = False\n        if values.get(\"is_class_or_interface_declaration\") and not values.get(\"is_interface\"):\n            if \"abstract\" not in values.get(\"modifiers\"):\n                values[\"is_concrete_class\"] = True\n        # since the methods in this class need access to the concrete class flag,\n        # we will store this in a context var - this is a hack\n        token = context_concrete_class.set(values[\"is_concrete_class\"])\n        return values\n\n    # after model validation is done we populate the is_entry_point flag by checking\n    # if the class extends or implements known servlet classes\n    @model_validator(mode=\"after\")\n    def check_concrete_entry_point(self):\n        \"\"\"Detects if the class is entry point based on its properties.\"\"\"\n        if self.is_concrete_class:\n            if any(substring in string for substring in (self.extends_list + self.implements_list) for string in constants.ENTRY_POINT_SERVLET_CLASSES):\n                self.is_entry_point = True\n                return self\n        # Handle spring classes\n        # clean annotations - take out @ and any paranehesis along with info in them.\n        annotations_cleaned = [match for annotation in self.annotations for match in re.findall(r\"@(.*?)(?:\\(|$)\", annotation)]\n        if any(substring in string for substring in annotations_cleaned for string in constants.ENTRY_POINT_CLASS_SPRING_ANNOTATIONS):\n            self.is_entry_point = True\n            return self\n        # context_concrete.reset()\n        return self\n</code></pre>"},{"location":"api_reference/#cldk.models.java.models.JType.check_concrete_class","title":"<code>check_concrete_class(values)</code>","text":"<p>Detects if the class is concrete based on its properties.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>@model_validator(mode=\"before\")\ndef check_concrete_class(cls, values):\n    \"\"\"Detects if the class is concrete based on its properties.\"\"\"\n    values[\"is_concrete_class\"] = False\n    if values.get(\"is_class_or_interface_declaration\") and not values.get(\"is_interface\"):\n        if \"abstract\" not in values.get(\"modifiers\"):\n            values[\"is_concrete_class\"] = True\n    # since the methods in this class need access to the concrete class flag,\n    # we will store this in a context var - this is a hack\n    token = context_concrete_class.set(values[\"is_concrete_class\"])\n    return values\n</code></pre>"},{"location":"api_reference/#cldk.models.java.models.JType.check_concrete_entry_point","title":"<code>check_concrete_entry_point()</code>","text":"<p>Detects if the class is entry point based on its properties.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_concrete_entry_point(self):\n    \"\"\"Detects if the class is entry point based on its properties.\"\"\"\n    if self.is_concrete_class:\n        if any(substring in string for substring in (self.extends_list + self.implements_list) for string in constants.ENTRY_POINT_SERVLET_CLASSES):\n            self.is_entry_point = True\n            return self\n    # Handle spring classes\n    # clean annotations - take out @ and any paranehesis along with info in them.\n    annotations_cleaned = [match for annotation in self.annotations for match in re.findall(r\"@(.*?)(?:\\(|$)\", annotation)]\n    if any(substring in string for substring in annotations_cleaned for string in constants.ENTRY_POINT_CLASS_SPRING_ANNOTATIONS):\n        self.is_entry_point = True\n        return self\n    # context_concrete.reset()\n    return self\n</code></pre>"},{"location":"api_reference/#cldk.models.java.models.JCompilationUnit","title":"<code>JCompilationUnit</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a compilation unit in Java.</p> <p>Attributes:</p> Name Type Description <code>comment</code> <code>str</code> <p>A comment associated with the compilation unit.</p> <code>imports</code> <code>List[str]</code> <p>A list of import statements in the compilation unit.</p> <code>type_declarations</code> <code>Dict[str, JType]</code> <p>A dictionary mapping type names to their corresponding JType representations.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JCompilationUnit(BaseModel):\n    \"\"\"Represents a compilation unit in Java.\n\n    Attributes:\n        comment (str): A comment associated with the compilation unit.\n        imports (List[str]): A list of import statements in the compilation unit.\n        type_declarations (Dict[str, JType]): A dictionary mapping type names to their corresponding JType representations.\n    \"\"\"\n\n    comment: str\n    imports: List[str]\n    type_declarations: Dict[str, JType]\n    is_modified: bool = False\n</code></pre>"},{"location":"api_reference/#cldk.models.java.models.JMethodDetail","title":"<code>JMethodDetail</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents details about a method in a Java class.</p> <p>Attributes:</p> Name Type Description <code>method_declaration</code> <code>str</code> <p>The declaration string of the method.</p> <code>klass</code> <code>str</code> <p>The name of the class containing the method. 'class' is a reserved keyword in Python.</p> <code>method</code> <code>JCallable</code> <p>An instance of JCallable representing the callable details of the method.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JMethodDetail(BaseModel):\n    \"\"\"Represents details about a method in a Java class.\n\n    Attributes:\n        method_declaration (str): The declaration string of the method.\n        klass (str): The name of the class containing the method. 'class' is a reserved keyword in Python.\n        method (JCallable): An instance of JCallable representing the callable details of the method.\n    \"\"\"\n\n    method_declaration: str\n    # class is a reserved keyword in python. we'll use klass.\n    klass: str\n    method: JCallable\n\n    def __repr__(self):\n        return f\"JMethodDetail({self.method_declaration})\"\n\n    def __hash__(self):\n        return hash(tuple(self))\n</code></pre>"},{"location":"api_reference/#cldk.models.java.models.JGraphEdgesST","title":"<code>JGraphEdgesST</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an edge in a graph structure for method dependencies.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>JMethodDetail</code> <p>The source method of the edge.</p> <code>target</code> <code>JMethodDetail</code> <p>The target method of the edge.</p> <code>type</code> <code>str</code> <p>The type of the edge.</p> <code>weight</code> <code>str</code> <p>The weight of the edge, indicating the strength or significance of the connection.</p> <code>source_kind</code> <code>Optional[str]</code> <p>The kind of the source method. Default is None.</p> <code>destination_kind</code> <code>Optional[str]</code> <p>The kind of the target method. Default is None.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JGraphEdgesST(BaseModel):\n    \"\"\"Represents an edge in a graph structure for method dependencies.\n\n    Attributes:\n        source (JMethodDetail): The source method of the edge.\n        target (JMethodDetail): The target method of the edge.\n        type (str): The type of the edge.\n        weight (str): The weight of the edge, indicating the strength or significance of the connection.\n        source_kind (Optional[str]): The kind of the source method. Default is None.\n        destination_kind (Optional[str]): The kind of the target method. Default is None.\n    \"\"\"\n\n    source: JMethodDetail\n    target: JMethodDetail\n    type: str\n    weight: str\n    source_kind: str | None = None\n    destination_kind: str | None = None\n</code></pre>"},{"location":"api_reference/#cldk.models.java.models.JApplication","title":"<code>JApplication</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a Java application.</p>"},{"location":"api_reference/#cldk.models.java.models.JApplication--parameters","title":"Parameters","text":"<p>symbol_table : List[JCompilationUnit]     The symbol table representation system_dependency : List[JGraphEdges]     The edges of the system dependency graph. Default None.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JApplication(BaseModel):\n    \"\"\"\n    Represents a Java application.\n\n    Parameters\n    ----------\n    symbol_table : List[JCompilationUnit]\n        The symbol table representation\n    system_dependency : List[JGraphEdges]\n        The edges of the system dependency graph. Default None.\n    \"\"\"\n\n    symbol_table: Dict[str, JCompilationUnit]\n    system_dependency_graph: List[JGraphEdges] = None\n\n    @field_validator(\"symbol_table\", mode=\"after\")\n    @classmethod\n    def validate_source(cls, symbol_table) -&gt; Dict[str, JCompilationUnit]:\n        # Populate the lookup table for callables\n        for _, j_compulation_unit in symbol_table.items():\n            for type_declaration, jtype in j_compulation_unit.type_declarations.items():\n                for __, j_callable in jtype.callable_declarations.items():\n                    _CALLABLES_LOOKUP_TABLE[(type_declaration, j_callable.signature)] = j_callable\n\n        return symbol_table\n</code></pre>"},{"location":"api_reference/#treesitter","title":"Treesitter","text":"<p>Models module</p> <p>Classes:</p> Name Description <code>Captures</code> <p>This class is a dataclass that represents the captures from a tree-sitter query.</p>"},{"location":"api_reference/#cldk.models.treesitter.models.Captures","title":"<code>Captures</code>  <code>dataclass</code>","text":"<p>This class is a dataclass that represents the captures from a tree-sitter query. Attributes</p> <p>captures : List[Capture]     A list of captures from the tree-sitter query.</p> <p>Classes:</p> Name Description <code>Capture</code> <p>This class is a dataclass that represents a single capture from a tree-sitter query.</p> <p>Methods:</p> Name Description <code>__getitem__</code> <p>Get the capture at the specified index.</p> <code>__iter__</code> <p>Return an iterator over the captures.</p> <code>__len__</code> <p>Return the number of captures.</p> Source code in <code>cldk/models/treesitter/models.py</code> <pre><code>@dataclass\nclass Captures:\n    \"\"\"This class is a dataclass that represents the captures from a tree-sitter query.\n    Attributes\n    ----------\n    captures : List[Capture]\n        A list of captures from the tree-sitter query.\n    \"\"\"\n\n    @dataclass\n    class Capture:\n        \"\"\"This class is a dataclass that represents a single capture from a tree-sitter query.\n        Attributes\n        ----------\n        node : Node\n            The node that was captured.\n        name : str\n            The name of the capture.\n        \"\"\"\n\n        node: Node\n        name: str\n\n    def __init__(self, captures: Dict[str, List[Node]]):\n        self.captures = []\n        for capture_name, captures in captures.items():\n            self.captures = [self.Capture(node=node, name=capture_name) for node in captures]\n\n    def __getitem__(self, index: int) -&gt; Capture:\n        \"\"\"Get the capture at the specified index.\n        Parameters:\n        -----------\n        index : int\n            The index of the capture to get.\n        Returns\n        -------\n        Capture\n            The capture at the specified index.\n        \"\"\"\n        return self.captures[index]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the captures.\"\"\"\n        return iter(self.captures)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of captures.\"\"\"\n        return len(self.captures)\n</code></pre>"},{"location":"api_reference/#cldk.models.treesitter.models.Captures.Capture","title":"<code>Capture</code>  <code>dataclass</code>","text":"<p>This class is a dataclass that represents a single capture from a tree-sitter query. Attributes</p> <p>node : Node     The node that was captured. name : str     The name of the capture.</p> Source code in <code>cldk/models/treesitter/models.py</code> <pre><code>@dataclass\nclass Capture:\n    \"\"\"This class is a dataclass that represents a single capture from a tree-sitter query.\n    Attributes\n    ----------\n    node : Node\n        The node that was captured.\n    name : str\n        The name of the capture.\n    \"\"\"\n\n    node: Node\n    name: str\n</code></pre>"},{"location":"api_reference/#cldk.models.treesitter.models.Captures.__getitem__","title":"<code>__getitem__(index: int) -&gt; Capture</code>","text":"<p>Get the capture at the specified index. Parameters:</p> <p>index : int     The index of the capture to get. Returns</p> <p>Capture     The capture at the specified index.</p> Source code in <code>cldk/models/treesitter/models.py</code> <pre><code>def __getitem__(self, index: int) -&gt; Capture:\n    \"\"\"Get the capture at the specified index.\n    Parameters:\n    -----------\n    index : int\n        The index of the capture to get.\n    Returns\n    -------\n    Capture\n        The capture at the specified index.\n    \"\"\"\n    return self.captures[index]\n</code></pre>"},{"location":"api_reference/#cldk.models.treesitter.models.Captures.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the captures.</p> Source code in <code>cldk/models/treesitter/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Return an iterator over the captures.\"\"\"\n    return iter(self.captures)\n</code></pre>"},{"location":"api_reference/#cldk.models.treesitter.models.Captures.__len__","title":"<code>__len__() -&gt; int</code>","text":"<p>Return the number of captures.</p> Source code in <code>cldk/models/treesitter/models.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of captures.\"\"\"\n    return len(self.captures)\n</code></pre>"},{"location":"api_reference/#python_1","title":"Python","text":"<p>Python package</p> <p>Modules:</p> Name Description <code>python_analysis</code> <p>Python module</p> <code>treesitter</code> <p>Treesitter package</p> <p>Classes:</p> Name Description <code>PythonAnalysis</code> <p>Python Analysis Class</p>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis","title":"<code>PythonAnalysis</code>","text":"<p>               Bases: <code>SymbolTable</code></p> <p>Python Analysis Class</p> <p>Methods:</p> Name Description <code>get_methods</code> <p>Given an application or a source code, get all the methods</p> <code>get_functions</code> <p>Given an application or a source code, get all the methods</p> <code>get_modules</code> <p>Given the project directory, get all the modules</p> <code>get_method_details</code> <p>Given the code body and the method signature, returns the method details related to that method</p> <code>is_parsable</code> <p>Check if the code is parsable</p> <code>get_raw_ast</code> <p>Get the raw AST</p> <code>get_imports</code> <p>Given an application or a source code, get all the imports</p> <code>get_variables</code> <p>Given an application or a source code, get all the variables</p> <code>get_classes</code> <p>Given an application or a source code, get all the classes</p> <code>get_classes_by_criteria</code> <p>Given an application or a source code, get all the classes given the inclusion and exclution criteria</p> <code>get_sub_classes</code> <p>Given an application or a source code, get all the sub-classes</p> <code>get_nested_classes</code> <p>Given an application or a source code, get all the nested classes</p> <code>get_constructors</code> <p>Given an application or a source code, get all the constructors</p> <code>get_methods_in_class</code> <p>Given an application or a source code, get all the methods within the given class</p> <code>get_fields</code> <p>Given an application or a source code, get all the fields</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>class PythonAnalysis(SymbolTable):\n    \"\"\"Python Analysis Class\"\"\"\n\n    def __init__(\n        self,\n        analysis_backend: str,\n        eager_analysis: bool,\n        project_dir: str | Path | None,\n        source_code: str | None,\n        analysis_backend_path: str | None,\n        analysis_json_path: str | Path | None,\n        use_graalvm_binary: bool = None,\n    ) -&gt; None:\n        self.project_dir = project_dir\n        self.source_code = source_code\n        self.analysis_json_path = analysis_json_path\n        self.analysis_backend_path = analysis_backend_path\n        self.eager_analysis = eager_analysis\n        self.use_graalvm_binary = use_graalvm_binary\n\n        # Initialize the analysis analysis_backend\n        if analysis_backend.lower() == \"codeql\":\n            raise NotImplementedError(\"Support for {analysis_backend} has not been implemented yet.\")\n        elif analysis_backend.lower() == \"codeanalyzer\":\n            raise NotImplementedError(\"Support for {analysis_backend} has not been implemented yet.\")\n        elif analysis_backend.lower() == \"treesitter\":\n            self.analysis_backend: PythonSitter = PythonSitter()\n        else:\n            raise NotImplementedError(\"Support for {analysis_backend} has not been implemented yet.\")\n\n    def get_methods(self) -&gt; List[PyMethod]:\n        \"\"\"\n        Given an application or a source code, get all the methods\n        \"\"\"\n        return self.analysis_backend.get_all_methods(self.source_code)\n\n    def get_functions(self) -&gt; List[PyMethod]:\n        \"\"\"\n        Given an application or a source code, get all the methods\n        \"\"\"\n        return self.analysis_backend.get_all_functions(self.source_code)\n\n    def get_modules(self) -&gt; List[PyModule]:\n        \"\"\"\n        Given the project directory, get all the modules\n        \"\"\"\n        return self.analysis_backend.get_all_modules(self.project_dir)\n\n    def get_method_details(self, method_signature: str) -&gt; PyMethod:\n        \"\"\"\n        Given the code body and the method signature, returns the method details related to that method\n        Parameters\n        ----------\n        method_signature: method signature\n\n        Returns\n        -------\n            PyMethod: Returns the method details related to that method\n        \"\"\"\n        return self.analysis_backend.get_method_details(self.source_code, method_signature)\n\n    def is_parsable(self, source_code: str) -&gt; bool:\n        \"\"\"\n        Check if the code is parsable\n        Args:\n            source_code: source code\n\n        Returns:\n            True if the code is parsable, False otherwise\n        \"\"\"\n        return PythonSitter().is_parsable(source_code)\n\n    def get_raw_ast(self, source_code: str) -&gt; str:\n        \"\"\"\n        Get the raw AST\n        Args:\n            code: source code\n\n        Returns:\n            Tree: the raw AST\n        \"\"\"\n        return PythonSitter().get_raw_ast(source_code)\n\n    def get_imports(self) -&gt; List[PyImport]:\n        \"\"\"\n        Given an application or a source code, get all the imports\n        \"\"\"\n        return self.analysis_backend.get_all_imports_details(self.source_code)\n\n    def get_variables(self, **kwargs):\n        \"\"\"\n        Given an application or a source code, get all the variables\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_classes(self) -&gt; List[PyClass]:\n        \"\"\"\n        Given an application or a source code, get all the classes\n        \"\"\"\n        return self.analysis_backend.get_all_classes(self.source_code)\n\n    def get_classes_by_criteria(self, **kwargs):\n        \"\"\"\n        Given an application or a source code, get all the classes given the inclusion and exclution criteria\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_sub_classes(self, **kwargs):\n        \"\"\"\n        Given an application or a source code, get all the sub-classes\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_nested_classes(self, **kwargs):\n        \"\"\"\n        Given an application or a source code, get all the nested classes\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_constructors(self, **kwargs):\n        \"\"\"\n        Given an application or a source code, get all the constructors\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_methods_in_class(self, **kwargs):\n        \"\"\"\n        Given an application or a source code, get all the methods within the given class\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_fields(self, **kwargs):\n        \"\"\"\n        Given an application or a source code, get all the fields\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_methods","title":"<code>get_methods() -&gt; List[PyMethod]</code>","text":"<p>Given an application or a source code, get all the methods</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_methods(self) -&gt; List[PyMethod]:\n    \"\"\"\n    Given an application or a source code, get all the methods\n    \"\"\"\n    return self.analysis_backend.get_all_methods(self.source_code)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_functions","title":"<code>get_functions() -&gt; List[PyMethod]</code>","text":"<p>Given an application or a source code, get all the methods</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_functions(self) -&gt; List[PyMethod]:\n    \"\"\"\n    Given an application or a source code, get all the methods\n    \"\"\"\n    return self.analysis_backend.get_all_functions(self.source_code)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_modules","title":"<code>get_modules() -&gt; List[PyModule]</code>","text":"<p>Given the project directory, get all the modules</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_modules(self) -&gt; List[PyModule]:\n    \"\"\"\n    Given the project directory, get all the modules\n    \"\"\"\n    return self.analysis_backend.get_all_modules(self.project_dir)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_method_details","title":"<code>get_method_details(method_signature: str) -&gt; PyMethod</code>","text":"<p>Given the code body and the method signature, returns the method details related to that method Parameters</p> <p>method_signature: method signature</p>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_method_details--returns","title":"Returns","text":"<pre><code>PyMethod: Returns the method details related to that method\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_method_details(self, method_signature: str) -&gt; PyMethod:\n    \"\"\"\n    Given the code body and the method signature, returns the method details related to that method\n    Parameters\n    ----------\n    method_signature: method signature\n\n    Returns\n    -------\n        PyMethod: Returns the method details related to that method\n    \"\"\"\n    return self.analysis_backend.get_method_details(self.source_code, method_signature)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.is_parsable","title":"<code>is_parsable(source_code: str) -&gt; bool</code>","text":"<p>Check if the code is parsable Args:     source_code: source code</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the code is parsable, False otherwise</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def is_parsable(self, source_code: str) -&gt; bool:\n    \"\"\"\n    Check if the code is parsable\n    Args:\n        source_code: source code\n\n    Returns:\n        True if the code is parsable, False otherwise\n    \"\"\"\n    return PythonSitter().is_parsable(source_code)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_raw_ast","title":"<code>get_raw_ast(source_code: str) -&gt; str</code>","text":"<p>Get the raw AST Args:     code: source code</p> <p>Returns:</p> Name Type Description <code>Tree</code> <code>str</code> <p>the raw AST</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_raw_ast(self, source_code: str) -&gt; str:\n    \"\"\"\n    Get the raw AST\n    Args:\n        code: source code\n\n    Returns:\n        Tree: the raw AST\n    \"\"\"\n    return PythonSitter().get_raw_ast(source_code)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_imports","title":"<code>get_imports() -&gt; List[PyImport]</code>","text":"<p>Given an application or a source code, get all the imports</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_imports(self) -&gt; List[PyImport]:\n    \"\"\"\n    Given an application or a source code, get all the imports\n    \"\"\"\n    return self.analysis_backend.get_all_imports_details(self.source_code)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_variables","title":"<code>get_variables(**kwargs)</code>","text":"<p>Given an application or a source code, get all the variables</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_variables(self, **kwargs):\n    \"\"\"\n    Given an application or a source code, get all the variables\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_classes","title":"<code>get_classes() -&gt; List[PyClass]</code>","text":"<p>Given an application or a source code, get all the classes</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_classes(self) -&gt; List[PyClass]:\n    \"\"\"\n    Given an application or a source code, get all the classes\n    \"\"\"\n    return self.analysis_backend.get_all_classes(self.source_code)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_classes_by_criteria","title":"<code>get_classes_by_criteria(**kwargs)</code>","text":"<p>Given an application or a source code, get all the classes given the inclusion and exclution criteria</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_classes_by_criteria(self, **kwargs):\n    \"\"\"\n    Given an application or a source code, get all the classes given the inclusion and exclution criteria\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_sub_classes","title":"<code>get_sub_classes(**kwargs)</code>","text":"<p>Given an application or a source code, get all the sub-classes</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_sub_classes(self, **kwargs):\n    \"\"\"\n    Given an application or a source code, get all the sub-classes\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_nested_classes","title":"<code>get_nested_classes(**kwargs)</code>","text":"<p>Given an application or a source code, get all the nested classes</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_nested_classes(self, **kwargs):\n    \"\"\"\n    Given an application or a source code, get all the nested classes\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_constructors","title":"<code>get_constructors(**kwargs)</code>","text":"<p>Given an application or a source code, get all the constructors</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_constructors(self, **kwargs):\n    \"\"\"\n    Given an application or a source code, get all the constructors\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_methods_in_class","title":"<code>get_methods_in_class(**kwargs)</code>","text":"<p>Given an application or a source code, get all the methods within the given class</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_methods_in_class(self, **kwargs):\n    \"\"\"\n    Given an application or a source code, get all the methods within the given class\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.python.PythonAnalysis.get_fields","title":"<code>get_fields(**kwargs)</code>","text":"<p>Given an application or a source code, get all the fields</p> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_fields(self, **kwargs):\n    \"\"\"\n    Given an application or a source code, get all the fields\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#java_1","title":"Java","text":"<p>Java package</p> <p>Modules:</p> Name Description <code>codeanalyzer</code> <p>Codeanalyzer package</p> <code>codeql</code> <p>CodeQL package</p> <code>java_analysis</code> <p>Java module</p> <code>treesitter</code> <p>Treesitter package</p> <p>Classes:</p> Name Description <code>JavaAnalysis</code>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis","title":"<code>JavaAnalysis</code>","text":"<p>               Bases: <code>SymbolTable</code>, <code>CallGraph</code></p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initialization method for Java Analysis backend.</p> <code>get_imports</code> <p>Returns all the imports in the source code.</p> <code>get_variables</code> <p>_Returns all the variables.</p> <code>get_service_entry_point_classes</code> <p>Returns all service entry point classes.</p> <code>get_service_entry_point_methods</code> <p>Returns all the service entry point methods.</p> <code>get_application_view</code> <p>Returns application view of the java code.</p> <code>get_symbol_table</code> <p>Returns symbol table.</p> <code>get_compilation_units</code> <p>Returns a list of all compilation units in the java code.</p> <code>get_class_hierarchy</code> <p>Returns class hierarchy of the java code.</p> <code>is_parsable</code> <p>Check if the code is parsable</p> <code>get_raw_ast</code> <p>Get the raw AST</p> <code>get_call_graph</code> <p>Returns the call graph of the Java code.</p> <code>get_call_graph_json</code> <p>Returns a serialized call graph in json.</p> <code>get_callers</code> <p>Returns a dictionary of callers of the target method.</p> <code>get_callees</code> <p>Returns a dictionary of callees by the given method in the given class.</p> <code>get_methods</code> <p>Returns all methods in the Java code.</p> <code>get_classes</code> <p>Returns all classes in the Java code.</p> <code>get_classes_by_criteria</code> <p>Returns a dictionary of all classes with the given criteria, in the Java code.</p> <code>get_class</code> <p>Returns a class object given qualified class name.</p> <code>get_method</code> <p>Returns a method object given qualified class and method names.</p> <code>get_java_file</code> <p>Returns a class given qualified class name.</p> <code>get_java_compilation_unit</code> <p>Given the path of a Java source file, returns the compilation unit object from the symbol table.</p> <code>get_methods_in_class</code> <p>Returns a dictionary of all methods of the given class.</p> <code>get_constructors</code> <p>Returns a dictionary of all constructors of the given class.</p> <code>get_fields</code> <p>Returns a dictionary of all fields of the given class</p> <code>get_nested_classes</code> <p>Returns a dictionary of all nested classes of the given class</p> <code>get_sub_classes</code> <p>Returns a dictionary of all sub-classes of the given class</p> <code>get_extended_classes</code> <p>Returns a list of all extended classes for the given class.</p> <code>get_implemented_interfaces</code> <p>Returns a list of all implemented interfaces for the given class.</p> <code>get_class_call_graph</code> <p>A call graph for a given class and (optionally) a given method.</p> <code>get_entry_point_classes</code> <p>Returns a dictionary of all entry point classes in the Java code.</p> <code>get_entry_point_methods</code> <p>Returns a dictionary of all entry point methods in the Java code with qualified class name as key and dictionary of methods in that class as value</p> <code>remove_all_comments</code> <p>Remove all comments from the source code.</p> <code>get_methods_with_annotations</code> <p>Returns a dictionary of method names and method bodies.</p> <code>get_test_methods</code> <p>Returns a dictionary of method names and method bodies.</p> <code>get_calling_lines</code> <p>Returns a list of line numbers in source method block where target method is called.</p> <code>get_call_targets</code> <p>Uses simple name resolution for finding the call targets. Nothing sophiscticed here. Just a simple search over the AST.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>class JavaAnalysis(SymbolTable, CallGraph):\n\n    def __init__(\n        self,\n        project_dir: str | Path | None,\n        source_code: str | None,\n        analysis_backend: str,\n        analysis_backend_path: str | None,\n        analysis_json_path: str | Path | None,\n        analysis_level: str,\n        target_files: List[str] | None,\n        use_graalvm_binary: bool,\n        eager_analysis: bool,\n    ) -&gt; None:\n        \"\"\"Initialization method for Java Analysis backend.\n\n        Args:\n            project_dir (str | Path | None): The directory path of the project.\n            source_code (str | None): Java file for single source file analysis.\n            analysis_backend (str): The analysis_backend used for analysis. Currently 'codeql' and 'codeanalyzer' are supported.\n            analysis_backend_path (str | None): The path to the analysis_backend, defaults to None and in the case of codeql, it is assumed that the cli is installed and available in the PATH. In the case of codeanalyzer the codeanalyzer.jar is downloaded from the lastest release.\n            analysis_json_path (str | Path | None): The path save the to the analysis database (analysis.json), defaults to None. If None, the analysis database is not persisted.\n            analysis_level (str): Analysis level (symbol-table, call-graph)\n            use_graalvm_binary (bool): A flag indicating whether to use the GraalVM binary for SDG analysis, defaults to False. If False, the default Java binary is used and one needs to have Java 17 or higher installed.\n            eager_analysis (bool): A flag indicating whether to perform eager analysis, defaults to False. If True, the analysis is performed eagerly. That is, the analysis.json file is created during analysis every time even if it already exists.\n\n        Raises:\n            NotImplementedError: Raised when anaysis backend is not supported.\n\n        Attributes:\n            application (JApplication): The application view of the Java code.\n\n        \"\"\"\n\n        self.project_dir = project_dir\n        self.source_code = source_code\n        self.analysis_level = analysis_level\n        self.analysis_json_path = analysis_json_path\n        self.analysis_backend_path = analysis_backend_path\n        self.eager_analysis = eager_analysis\n        self.use_graalvm_binary = use_graalvm_binary\n        self.analysis_backend = analysis_backend\n        self.target_files = target_files\n        # Initialize the analysis analysis_backend\n        if analysis_backend.lower() == \"codeql\":\n            self.analysis_backend: JCodeQL = JCodeQL(self.project_dir, self.analysis_json_path)\n        elif analysis_backend.lower() == \"codeanalyzer\":\n            self.backend: JCodeanalyzer = JCodeanalyzer(\n                project_dir=self.project_dir,\n                source_code=self.source_code,\n                eager_analysis=self.eager_analysis,\n                analysis_level=self.analysis_level,\n                analysis_json_path=self.analysis_json_path,\n                use_graalvm_binary=self.use_graalvm_binary,\n                analysis_backend_path=self.analysis_backend_path,\n                target_files=self.target_files,\n            )\n        else:\n            raise NotImplementedError(f\"Support for {analysis_backend} has not been implemented yet.\")\n\n    def get_imports(self) -&gt; List[str]:\n        \"\"\"Returns all the imports in the source code.\n\n        Raises:\n            NotImplementedError: Raised when this functionality is not suported.\n\n        Returns:\n            List[str]: List of all the imports.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_variables(self, **kwargs):\n        \"\"\"_Returns all the variables.\n\n        Raises:\n            NotImplementedError: Raised when this functionality is not suported.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_service_entry_point_classes(self, **kwargs):\n        \"\"\"Returns all service entry point classes.\n\n        Raises:\n            NotImplementedError: Raised when this functionality is not suported.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_service_entry_point_methods(self, **kwargs):\n        \"\"\"Returns all the service entry point methods.\n\n        Raises:\n            NotImplementedError: Raised when this functionality is not suported.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_application_view(self) -&gt; JApplication:\n        \"\"\"Returns application view of the java code.\n\n        Raises:\n            NotImplementedError: Raised when this functionality is not suported.\n\n        Returns:\n            JApplication: Application view of the java code.\n        \"\"\"\n        if self.source_code:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_application_view()\n\n    def get_symbol_table(self) -&gt; Dict[str, JCompilationUnit]:\n        \"\"\"Returns symbol table.\n\n        Returns:\n            Dict[str, JCompilationUnit]: Symbol table\n        \"\"\"\n        return self.backend.get_symbol_table()\n\n    def get_compilation_units(self) -&gt; List[JCompilationUnit]:\n        \"\"\"Returns a list of all compilation units in the java code.\n\n        Raises:\n            NotImplementedError: Raised when this functionality is not supported.\n\n        Returns:\n            List[JCompilationUnit]: Compilation units of the Java code.\n        \"\"\"\n\n        # TODO: This code is broken:\n        # JCodeanalyzer does not have a get_compilation_units() method\n        # Commenting out until implemented\n\n        # if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        #     raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        # return self.backend.get_compilation_units()\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_class_hierarchy(self) -&gt; DiGraph:\n        \"\"\"Returns class hierarchy of the java code.\n\n        Raises:\n            NotImplementedError: Raised when this functionality is not suported.\n\n        Returns:\n            DiGraph: The class hierarchy of the Java code.\n        \"\"\"\n\n        if self.backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        raise NotImplementedError(\"Class hierarchy is not implemented yet.\")\n\n    def is_parsable(self, source_code: str) -&gt; bool:\n        \"\"\"\n        Check if the code is parsable\n        Args:\n            source_code: source code\n\n        Returns:\n            True if the code is parsable, False otherwise\n        \"\"\"\n        return JavaSitter().is_parsable(source_code)\n\n    def get_raw_ast(self, source_code: str) -&gt; Tree:\n        \"\"\"\n        Get the raw AST\n        Args:\n            code: source code\n\n        Returns:\n            Tree: the raw AST\n        \"\"\"\n        return JavaSitter().get_raw_ast(source_code)\n\n    def get_call_graph(self) -&gt; DiGraph:\n        \"\"\"Returns the call graph of the Java code.\n\n        Returns:\n            DiGraph: The call graph of the Java code.\n        \"\"\"\n        return self.backend.get_call_graph()\n\n    def get_call_graph_json(self) -&gt; str:\n        \"\"\"Returns a serialized call graph in json.\n\n        Raises:\n            NotImplementedError: Raised when this functionality is not suported.\n\n        Returns:\n            str: Call graph in json.\n        \"\"\"\n        if self.source_code:\n            raise NotImplementedError(\"Producing a call graph over a single file is not implemented yet.\")\n        return self.backend.get_call_graph_json()\n\n    def get_callers(self, target_class_name: str, target_method_declaration: str, using_symbol_table: bool = False) -&gt; Dict:\n        \"\"\"Returns a dictionary of callers of the target method.\n\n        Args:\n            target_class_name (str): Qualified target class name.\n            target_method_declaration (str): Target method names\n            using_symbol_table (bool, optional): Whether to use symbol table. Defaults to False.\n\n        Raises:\n            NotImplementedError: Raised when this functionality is not suported.\n\n        Returns:\n            Dict: A dictionary of callers of target method.\n        \"\"\"\n\n        if self.source_code:\n            raise NotImplementedError(\"Generating all callers over a single file is not implemented yet.\")\n        return self.backend.get_all_callers(target_class_name, target_method_declaration, using_symbol_table)\n\n    def get_callees(self, source_class_name: str, source_method_declaration: str, using_symbol_table: bool = False) -&gt; Dict:\n        \"\"\"Returns a dictionary of callees by the given method in the given class.\n\n        Args:\n            source_class_name (str): Qualified class name where the given method is.\n            source_method_declaration (str): Given method\n            using_symbol_table (bool): Whether to use symbol table.  Defaults to false.\n\n        Raises:\n            NotImplementedError: Raised when this functionality is not suported.\n\n        Returns:\n            Dict: Dictionary with callee details.\n        \"\"\"\n        if self.source_code:\n            raise NotImplementedError(\"Generating all callees over a single file is not implemented yet.\")\n        return self.backend.get_all_callees(source_class_name, source_method_declaration, using_symbol_table)\n\n    def get_methods(self) -&gt; Dict[str, Dict[str, JCallable]]:\n        \"\"\"Returns all methods in the Java code.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            Dict[str, Dict[str, JCallable]]: Dictionary of dictionaries of all methods in the Java code with qualified class name as key and dictionary of methods in that class.\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_all_methods_in_application()\n\n    def get_classes(self) -&gt; Dict[str, JType]:\n        \"\"\"Returns all classes in the Java code.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            Dict[str, JType]: A dictionary of all classes in the Java code, with qualified class names as keys.\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_all_classes()\n\n    def get_classes_by_criteria(self, inclusions=None, exclusions=None) -&gt; Dict[str, JType]:\n        \"\"\"Returns a dictionary of all classes with the given criteria, in the Java code.\n\n        Args:\n            inclusions (List, optional): inlusion criteria for the classes. Defaults to None.\n            exclusions (List, optional): exclusion criteria for the classes. Defaults to None.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            Dict[str, JType]: A dict of all classes in the Java code, with qualified class names as keys\n        \"\"\"\n\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n        if exclusions is None:\n            exclusions = []\n        if inclusions is None:\n            inclusions = []\n        class_dict: Dict[str, JType] = {}\n        all_classes = self.backend.get_all_classes()\n        for application_class in all_classes:\n            is_selected = False\n            for inclusion in inclusions:\n                if inclusion in application_class:\n                    is_selected = True\n\n            for exclusion in exclusions:\n                if exclusion in application_class:\n                    is_selected = False\n            if is_selected:\n                class_dict[application_class] = all_classes[application_class]\n        return class_dict\n\n    def get_class(self, qualified_class_name: str) -&gt; JType:\n        \"\"\"Returns a class object given qualified class name.\n\n        Args:\n            qualified_class_name (str): The qualified name of the class.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            JType: Class object for the given qualified class name.\n        \"\"\"\n\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_class(qualified_class_name)\n\n    def get_method(self, qualified_class_name: str, qualified_method_name: str) -&gt; JCallable:\n        \"\"\"Returns a method object given qualified class and method names.\n\n        Args:\n            qualified_class_name (str): The qualified name of the class.\n            qualified_method_name (str): The qualified name of the method.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            JCallable: A method for the given qualified method name.\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_method(qualified_class_name, qualified_method_name)\n\n    def get_java_file(self, qualified_class_name: str) -&gt; str:\n        \"\"\"Returns a class given qualified class name.\n\n        Args:\n            qualified_class_name (str): The qualified name of the class.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            str: Java file name containing the given qualified class.\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_java_file(qualified_class_name)\n\n    def get_java_compilation_unit(self, file_path: str) -&gt; JCompilationUnit:\n        \"\"\"Given the path of a Java source file, returns the compilation unit object from the symbol table.\n\n        Args:\n            file_path (str): Absolute path to Java source file\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            JCompilationUnit: Compilation unit object for Java source file\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_java_compilation_unit(file_path)\n\n    def get_methods_in_class(self, qualified_class_name) -&gt; Dict[str, JCallable]:\n        \"\"\"Returns a dictionary of all methods of the given class.\n\n        Args:\n            qualified_class_name (str): qualified class name\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            Dict[str, JCallable]: A dictionary of all constructors of the given class.\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_all_methods_in_class(qualified_class_name)\n\n    def get_constructors(self, qualified_class_name) -&gt; Dict[str, JCallable]:\n        \"\"\"Returns a dictionary of all constructors of the given class.\n\n        Args:\n            qualified_class_name (str): qualified class name\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            Dict[str, JCallable]: A dictionary of all constructors of the given class.\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_all_constructors(qualified_class_name)\n\n    def get_fields(self, qualified_class_name) -&gt; List[JField]:\n        \"\"\"Returns a dictionary of all fields of the given class\n\n        Args:\n            qualified_class_name (str): qualified class name\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            List[JField]: A list of all fields of the given class.\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_all_fields(qualified_class_name)\n\n    def get_nested_classes(self, qualified_class_name) -&gt; List[JType]:\n        \"\"\"Returns a dictionary of all nested classes of the given class\n\n        Args:\n            qualified_class_name (str): qualified class name\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            List[JType]: A list of nested classes for the given class.\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_all_nested_classes(qualified_class_name)\n\n    def get_sub_classes(self, qualified_class_name) -&gt; Dict[str, JType]:\n        \"\"\"Returns a dictionary of all sub-classes of the given class\n\n        Args:\n            qualified_class_name (str): qualified class name\n\n        Returns:\n            Dict[str, JType]: A dictionary of all sub-classes of the given class, and class details\n        \"\"\"\n        return self.backend.get_all_sub_classes(qualified_class_name=qualified_class_name)\n\n    def get_extended_classes(self, qualified_class_name) -&gt; List[str]:\n        \"\"\"Returns a list of all extended classes for the given class.\n        Args:\n            qualified_class_name (str): The qualified name of the class.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            List[str]: A list of extended classes for the given class.\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_extended_classes(qualified_class_name)\n\n    def get_implemented_interfaces(self, qualified_class_name: str) -&gt; List[str]:\n        \"\"\"Returns a list of all implemented interfaces for the given class.\n\n        Args:\n            qualified_class_name (str): The qualified name of the class.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            List[str]: A list of implemented interfaces for the given class.\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_implemented_interfaces(qualified_class_name)\n\n    def __get_class_call_graph_using_symbol_table(self, qualified_class_name: str, method_signature: str | None = None) -&gt; (List)[Tuple[JMethodDetail, JMethodDetail]]:\n        \"\"\"A call graph using symbol table for a given class and a given method.\n\n        Args:\n            qualified_class_name (str): The qualified name of the class.\n            method_signature (str | None, optional): The signature of the method in the class.. Defaults to None.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            List[Tuple[JMethodDetail, JMethodDetail]]: An edge list of the call graph for the given class and method.\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_class_call_graph_using_symbol_table(qualified_class_name, method_signature)\n\n    def get_class_call_graph(self, qualified_class_name: str, method_signature: str | None = None, using_symbol_table: bool = False) -&gt; List[Tuple[JMethodDetail, JMethodDetail]]:\n        \"\"\"A call graph for a given class and (optionally) a given method.\n\n        Args:\n            qualified_class_name (str): The qualified name of the class.\n            method_signature (str | None, optional): The signature of the method in the class.. Defaults to None.\n            using_symbol_table (bool, optional): Generate call graph using symbol table. Defaults to False.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            List[Tuple[JMethodDetail, JMethodDetail]]: An edge list of the call graph for the given class and method.\n        \"\"\"\n        if using_symbol_table:\n            return self.__get_class_call_graph_using_symbol_table(qualified_class_name=qualified_class_name, method_signature=method_signature)\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_class_call_graph(qualified_class_name, method_signature)\n\n    def get_entry_point_classes(self) -&gt; Dict[str, JType]:\n        \"\"\"Returns a dictionary of all entry point classes in the Java code.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            Dict[str, JType]: A dict of all entry point classes in the Java code, with qualified class names as keys\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_all_entry_point_classes()\n\n    def get_entry_point_methods(self) -&gt; Dict[str, Dict[str, JCallable]]:\n        \"\"\"Returns a dictionary of all entry point methods in the Java code with qualified class name as key and dictionary of methods in that class as value\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            Dict[str, Dict[str, JCallable]]: A dictionary of dictionaries of entry point methods in the Java code.\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_all_entry_point_methods()\n\n    def remove_all_comments(self) -&gt; str:\n        \"\"\"Remove all comments from the source code.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            str: The source code with all comments removed.\n        \"\"\"\n        # Remove any prefix comments/content before the package declaration\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.CODEANALYZER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.remove_all_comments(self.source_code)\n\n    def get_methods_with_annotations(self, annotations: List[str]) -&gt; Dict[str, List[Dict]]:\n        \"\"\"Returns a dictionary of method names and method bodies.\n\n        Args:\n            annotations (List[str]): List of annotation strings.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            Dict[str, List[Dict]]: Dictionary with annotations as keys and a list of dictionaries containing method names and bodies, as values.\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.CODEANALYZER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_methods_with_annotations(self.source_code, annotations)\n\n    def get_test_methods(self) -&gt; Dict[str, str]:\n        \"\"\"Returns a dictionary of method names and method bodies.\n\n        Args:\n            source_class_code (str): String containing code for a java class.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            Dict[str, str]: Dictionary of method names and method bodies.\n        \"\"\"\n\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.CODEANALYZER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_test_methods(self.source_code)\n\n    def get_calling_lines(self, target_method_name: str) -&gt; List[int]:\n        \"\"\"Returns a list of line numbers in source method block where target method is called.\n\n        Args:\n            target_method_name (str): target method  name.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            List[int]: List of line numbers within in source method code block.\n        \"\"\"\n\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_calling_lines(self.source_code, target_method_name)\n\n    def get_call_targets(self, declared_methods: dict) -&gt; Set[str]:\n        \"\"\"Uses simple name resolution for finding the call targets. Nothing sophiscticed here. Just a simple search over the AST.\n\n        Args:\n            declared_methods (dict): A dictionary of all declared methods in the class.\n\n        Raises:\n            NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n        Returns:\n            Set[str]: A list of call targets (methods).\n        \"\"\"\n        if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_call_targets(self.source_code, declared_methods)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.__init__","title":"<code>__init__(project_dir: str | Path | None, source_code: str | None, analysis_backend: str, analysis_backend_path: str | None, analysis_json_path: str | Path | None, analysis_level: str, target_files: List[str] | None, use_graalvm_binary: bool, eager_analysis: bool) -&gt; None</code>","text":"<p>Initialization method for Java Analysis backend.</p> <p>Parameters:</p> Name Type Description Default <code>project_dir</code> <code>str | Path | None</code> <p>The directory path of the project.</p> required <code>source_code</code> <code>str | None</code> <p>Java file for single source file analysis.</p> required <code>analysis_backend</code> <code>str</code> <p>The analysis_backend used for analysis. Currently 'codeql' and 'codeanalyzer' are supported.</p> required <code>analysis_backend_path</code> <code>str | None</code> <p>The path to the analysis_backend, defaults to None and in the case of codeql, it is assumed that the cli is installed and available in the PATH. In the case of codeanalyzer the codeanalyzer.jar is downloaded from the lastest release.</p> required <code>analysis_json_path</code> <code>str | Path | None</code> <p>The path save the to the analysis database (analysis.json), defaults to None. If None, the analysis database is not persisted.</p> required <code>analysis_level</code> <code>str</code> <p>Analysis level (symbol-table, call-graph)</p> required <code>use_graalvm_binary</code> <code>bool</code> <p>A flag indicating whether to use the GraalVM binary for SDG analysis, defaults to False. If False, the default Java binary is used and one needs to have Java 17 or higher installed.</p> required <code>eager_analysis</code> <code>bool</code> <p>A flag indicating whether to perform eager analysis, defaults to False. If True, the analysis is performed eagerly. That is, the analysis.json file is created during analysis every time even if it already exists.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when anaysis backend is not supported.</p> <p>Attributes:</p> Name Type Description <code>application</code> <code>JApplication</code> <p>The application view of the Java code.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def __init__(\n    self,\n    project_dir: str | Path | None,\n    source_code: str | None,\n    analysis_backend: str,\n    analysis_backend_path: str | None,\n    analysis_json_path: str | Path | None,\n    analysis_level: str,\n    target_files: List[str] | None,\n    use_graalvm_binary: bool,\n    eager_analysis: bool,\n) -&gt; None:\n    \"\"\"Initialization method for Java Analysis backend.\n\n    Args:\n        project_dir (str | Path | None): The directory path of the project.\n        source_code (str | None): Java file for single source file analysis.\n        analysis_backend (str): The analysis_backend used for analysis. Currently 'codeql' and 'codeanalyzer' are supported.\n        analysis_backend_path (str | None): The path to the analysis_backend, defaults to None and in the case of codeql, it is assumed that the cli is installed and available in the PATH. In the case of codeanalyzer the codeanalyzer.jar is downloaded from the lastest release.\n        analysis_json_path (str | Path | None): The path save the to the analysis database (analysis.json), defaults to None. If None, the analysis database is not persisted.\n        analysis_level (str): Analysis level (symbol-table, call-graph)\n        use_graalvm_binary (bool): A flag indicating whether to use the GraalVM binary for SDG analysis, defaults to False. If False, the default Java binary is used and one needs to have Java 17 or higher installed.\n        eager_analysis (bool): A flag indicating whether to perform eager analysis, defaults to False. If True, the analysis is performed eagerly. That is, the analysis.json file is created during analysis every time even if it already exists.\n\n    Raises:\n        NotImplementedError: Raised when anaysis backend is not supported.\n\n    Attributes:\n        application (JApplication): The application view of the Java code.\n\n    \"\"\"\n\n    self.project_dir = project_dir\n    self.source_code = source_code\n    self.analysis_level = analysis_level\n    self.analysis_json_path = analysis_json_path\n    self.analysis_backend_path = analysis_backend_path\n    self.eager_analysis = eager_analysis\n    self.use_graalvm_binary = use_graalvm_binary\n    self.analysis_backend = analysis_backend\n    self.target_files = target_files\n    # Initialize the analysis analysis_backend\n    if analysis_backend.lower() == \"codeql\":\n        self.analysis_backend: JCodeQL = JCodeQL(self.project_dir, self.analysis_json_path)\n    elif analysis_backend.lower() == \"codeanalyzer\":\n        self.backend: JCodeanalyzer = JCodeanalyzer(\n            project_dir=self.project_dir,\n            source_code=self.source_code,\n            eager_analysis=self.eager_analysis,\n            analysis_level=self.analysis_level,\n            analysis_json_path=self.analysis_json_path,\n            use_graalvm_binary=self.use_graalvm_binary,\n            analysis_backend_path=self.analysis_backend_path,\n            target_files=self.target_files,\n        )\n    else:\n        raise NotImplementedError(f\"Support for {analysis_backend} has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_imports","title":"<code>get_imports() -&gt; List[str]</code>","text":"<p>Returns all the imports in the source code.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when this functionality is not suported.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of all the imports.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_imports(self) -&gt; List[str]:\n    \"\"\"Returns all the imports in the source code.\n\n    Raises:\n        NotImplementedError: Raised when this functionality is not suported.\n\n    Returns:\n        List[str]: List of all the imports.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_variables","title":"<code>get_variables(**kwargs)</code>","text":"<p>_Returns all the variables.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when this functionality is not suported.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_variables(self, **kwargs):\n    \"\"\"_Returns all the variables.\n\n    Raises:\n        NotImplementedError: Raised when this functionality is not suported.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_service_entry_point_classes","title":"<code>get_service_entry_point_classes(**kwargs)</code>","text":"<p>Returns all service entry point classes.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when this functionality is not suported.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_service_entry_point_classes(self, **kwargs):\n    \"\"\"Returns all service entry point classes.\n\n    Raises:\n        NotImplementedError: Raised when this functionality is not suported.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_service_entry_point_methods","title":"<code>get_service_entry_point_methods(**kwargs)</code>","text":"<p>Returns all the service entry point methods.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when this functionality is not suported.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_service_entry_point_methods(self, **kwargs):\n    \"\"\"Returns all the service entry point methods.\n\n    Raises:\n        NotImplementedError: Raised when this functionality is not suported.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_application_view","title":"<code>get_application_view() -&gt; JApplication</code>","text":"<p>Returns application view of the java code.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when this functionality is not suported.</p> <p>Returns:</p> Name Type Description <code>JApplication</code> <code>JApplication</code> <p>Application view of the java code.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_application_view(self) -&gt; JApplication:\n    \"\"\"Returns application view of the java code.\n\n    Raises:\n        NotImplementedError: Raised when this functionality is not suported.\n\n    Returns:\n        JApplication: Application view of the java code.\n    \"\"\"\n    if self.source_code:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_application_view()\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_symbol_table","title":"<code>get_symbol_table() -&gt; Dict[str, JCompilationUnit]</code>","text":"<p>Returns symbol table.</p> <p>Returns:</p> Type Description <code>Dict[str, JCompilationUnit]</code> <p>Dict[str, JCompilationUnit]: Symbol table</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_symbol_table(self) -&gt; Dict[str, JCompilationUnit]:\n    \"\"\"Returns symbol table.\n\n    Returns:\n        Dict[str, JCompilationUnit]: Symbol table\n    \"\"\"\n    return self.backend.get_symbol_table()\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_compilation_units","title":"<code>get_compilation_units() -&gt; List[JCompilationUnit]</code>","text":"<p>Returns a list of all compilation units in the java code.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when this functionality is not supported.</p> <p>Returns:</p> Type Description <code>List[JCompilationUnit]</code> <p>List[JCompilationUnit]: Compilation units of the Java code.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_compilation_units(self) -&gt; List[JCompilationUnit]:\n    \"\"\"Returns a list of all compilation units in the java code.\n\n    Raises:\n        NotImplementedError: Raised when this functionality is not supported.\n\n    Returns:\n        List[JCompilationUnit]: Compilation units of the Java code.\n    \"\"\"\n\n    # TODO: This code is broken:\n    # JCodeanalyzer does not have a get_compilation_units() method\n    # Commenting out until implemented\n\n    # if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n    #     raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    # return self.backend.get_compilation_units()\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_class_hierarchy","title":"<code>get_class_hierarchy() -&gt; DiGraph</code>","text":"<p>Returns class hierarchy of the java code.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when this functionality is not suported.</p> <p>Returns:</p> Name Type Description <code>DiGraph</code> <code>DiGraph</code> <p>The class hierarchy of the Java code.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_class_hierarchy(self) -&gt; DiGraph:\n    \"\"\"Returns class hierarchy of the java code.\n\n    Raises:\n        NotImplementedError: Raised when this functionality is not suported.\n\n    Returns:\n        DiGraph: The class hierarchy of the Java code.\n    \"\"\"\n\n    if self.backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    raise NotImplementedError(\"Class hierarchy is not implemented yet.\")\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.is_parsable","title":"<code>is_parsable(source_code: str) -&gt; bool</code>","text":"<p>Check if the code is parsable Args:     source_code: source code</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the code is parsable, False otherwise</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def is_parsable(self, source_code: str) -&gt; bool:\n    \"\"\"\n    Check if the code is parsable\n    Args:\n        source_code: source code\n\n    Returns:\n        True if the code is parsable, False otherwise\n    \"\"\"\n    return JavaSitter().is_parsable(source_code)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_raw_ast","title":"<code>get_raw_ast(source_code: str) -&gt; Tree</code>","text":"<p>Get the raw AST Args:     code: source code</p> <p>Returns:</p> Name Type Description <code>Tree</code> <code>Tree</code> <p>the raw AST</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_raw_ast(self, source_code: str) -&gt; Tree:\n    \"\"\"\n    Get the raw AST\n    Args:\n        code: source code\n\n    Returns:\n        Tree: the raw AST\n    \"\"\"\n    return JavaSitter().get_raw_ast(source_code)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_call_graph","title":"<code>get_call_graph() -&gt; DiGraph</code>","text":"<p>Returns the call graph of the Java code.</p> <p>Returns:</p> Name Type Description <code>DiGraph</code> <code>DiGraph</code> <p>The call graph of the Java code.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_call_graph(self) -&gt; DiGraph:\n    \"\"\"Returns the call graph of the Java code.\n\n    Returns:\n        DiGraph: The call graph of the Java code.\n    \"\"\"\n    return self.backend.get_call_graph()\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_call_graph_json","title":"<code>get_call_graph_json() -&gt; str</code>","text":"<p>Returns a serialized call graph in json.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when this functionality is not suported.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Call graph in json.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_call_graph_json(self) -&gt; str:\n    \"\"\"Returns a serialized call graph in json.\n\n    Raises:\n        NotImplementedError: Raised when this functionality is not suported.\n\n    Returns:\n        str: Call graph in json.\n    \"\"\"\n    if self.source_code:\n        raise NotImplementedError(\"Producing a call graph over a single file is not implemented yet.\")\n    return self.backend.get_call_graph_json()\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_callers","title":"<code>get_callers(target_class_name: str, target_method_declaration: str, using_symbol_table: bool = False) -&gt; Dict</code>","text":"<p>Returns a dictionary of callers of the target method.</p> <p>Parameters:</p> Name Type Description Default <code>target_class_name</code> <code>str</code> <p>Qualified target class name.</p> required <code>target_method_declaration</code> <code>str</code> <p>Target method names</p> required <code>using_symbol_table</code> <code>bool</code> <p>Whether to use symbol table. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when this functionality is not suported.</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>A dictionary of callers of target method.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_callers(self, target_class_name: str, target_method_declaration: str, using_symbol_table: bool = False) -&gt; Dict:\n    \"\"\"Returns a dictionary of callers of the target method.\n\n    Args:\n        target_class_name (str): Qualified target class name.\n        target_method_declaration (str): Target method names\n        using_symbol_table (bool, optional): Whether to use symbol table. Defaults to False.\n\n    Raises:\n        NotImplementedError: Raised when this functionality is not suported.\n\n    Returns:\n        Dict: A dictionary of callers of target method.\n    \"\"\"\n\n    if self.source_code:\n        raise NotImplementedError(\"Generating all callers over a single file is not implemented yet.\")\n    return self.backend.get_all_callers(target_class_name, target_method_declaration, using_symbol_table)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_callees","title":"<code>get_callees(source_class_name: str, source_method_declaration: str, using_symbol_table: bool = False) -&gt; Dict</code>","text":"<p>Returns a dictionary of callees by the given method in the given class.</p> <p>Parameters:</p> Name Type Description Default <code>source_class_name</code> <code>str</code> <p>Qualified class name where the given method is.</p> required <code>source_method_declaration</code> <code>str</code> <p>Given method</p> required <code>using_symbol_table</code> <code>bool</code> <p>Whether to use symbol table.  Defaults to false.</p> <code>False</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when this functionality is not suported.</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary with callee details.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_callees(self, source_class_name: str, source_method_declaration: str, using_symbol_table: bool = False) -&gt; Dict:\n    \"\"\"Returns a dictionary of callees by the given method in the given class.\n\n    Args:\n        source_class_name (str): Qualified class name where the given method is.\n        source_method_declaration (str): Given method\n        using_symbol_table (bool): Whether to use symbol table.  Defaults to false.\n\n    Raises:\n        NotImplementedError: Raised when this functionality is not suported.\n\n    Returns:\n        Dict: Dictionary with callee details.\n    \"\"\"\n    if self.source_code:\n        raise NotImplementedError(\"Generating all callees over a single file is not implemented yet.\")\n    return self.backend.get_all_callees(source_class_name, source_method_declaration, using_symbol_table)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_methods","title":"<code>get_methods() -&gt; Dict[str, Dict[str, JCallable]]</code>","text":"<p>Returns all methods in the Java code.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, JCallable]]</code> <p>Dict[str, Dict[str, JCallable]]: Dictionary of dictionaries of all methods in the Java code with qualified class name as key and dictionary of methods in that class.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_methods(self) -&gt; Dict[str, Dict[str, JCallable]]:\n    \"\"\"Returns all methods in the Java code.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        Dict[str, Dict[str, JCallable]]: Dictionary of dictionaries of all methods in the Java code with qualified class name as key and dictionary of methods in that class.\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_all_methods_in_application()\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_classes","title":"<code>get_classes() -&gt; Dict[str, JType]</code>","text":"<p>Returns all classes in the Java code.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>Dict[str, JType]</code> <p>Dict[str, JType]: A dictionary of all classes in the Java code, with qualified class names as keys.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_classes(self) -&gt; Dict[str, JType]:\n    \"\"\"Returns all classes in the Java code.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        Dict[str, JType]: A dictionary of all classes in the Java code, with qualified class names as keys.\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_all_classes()\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_classes_by_criteria","title":"<code>get_classes_by_criteria(inclusions=None, exclusions=None) -&gt; Dict[str, JType]</code>","text":"<p>Returns a dictionary of all classes with the given criteria, in the Java code.</p> <p>Parameters:</p> Name Type Description Default <code>inclusions</code> <code>List</code> <p>inlusion criteria for the classes. Defaults to None.</p> <code>None</code> <code>exclusions</code> <code>List</code> <p>exclusion criteria for the classes. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>Dict[str, JType]</code> <p>Dict[str, JType]: A dict of all classes in the Java code, with qualified class names as keys</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_classes_by_criteria(self, inclusions=None, exclusions=None) -&gt; Dict[str, JType]:\n    \"\"\"Returns a dictionary of all classes with the given criteria, in the Java code.\n\n    Args:\n        inclusions (List, optional): inlusion criteria for the classes. Defaults to None.\n        exclusions (List, optional): exclusion criteria for the classes. Defaults to None.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        Dict[str, JType]: A dict of all classes in the Java code, with qualified class names as keys\n    \"\"\"\n\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    if exclusions is None:\n        exclusions = []\n    if inclusions is None:\n        inclusions = []\n    class_dict: Dict[str, JType] = {}\n    all_classes = self.backend.get_all_classes()\n    for application_class in all_classes:\n        is_selected = False\n        for inclusion in inclusions:\n            if inclusion in application_class:\n                is_selected = True\n\n        for exclusion in exclusions:\n            if exclusion in application_class:\n                is_selected = False\n        if is_selected:\n            class_dict[application_class] = all_classes[application_class]\n    return class_dict\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_class","title":"<code>get_class(qualified_class_name: str) -&gt; JType</code>","text":"<p>Returns a class object given qualified class name.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>The qualified name of the class.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Name Type Description <code>JType</code> <code>JType</code> <p>Class object for the given qualified class name.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_class(self, qualified_class_name: str) -&gt; JType:\n    \"\"\"Returns a class object given qualified class name.\n\n    Args:\n        qualified_class_name (str): The qualified name of the class.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        JType: Class object for the given qualified class name.\n    \"\"\"\n\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_class(qualified_class_name)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_method","title":"<code>get_method(qualified_class_name: str, qualified_method_name: str) -&gt; JCallable</code>","text":"<p>Returns a method object given qualified class and method names.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>The qualified name of the class.</p> required <code>qualified_method_name</code> <code>str</code> <p>The qualified name of the method.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Name Type Description <code>JCallable</code> <code>JCallable</code> <p>A method for the given qualified method name.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_method(self, qualified_class_name: str, qualified_method_name: str) -&gt; JCallable:\n    \"\"\"Returns a method object given qualified class and method names.\n\n    Args:\n        qualified_class_name (str): The qualified name of the class.\n        qualified_method_name (str): The qualified name of the method.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        JCallable: A method for the given qualified method name.\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_method(qualified_class_name, qualified_method_name)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_java_file","title":"<code>get_java_file(qualified_class_name: str) -&gt; str</code>","text":"<p>Returns a class given qualified class name.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>The qualified name of the class.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Java file name containing the given qualified class.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_java_file(self, qualified_class_name: str) -&gt; str:\n    \"\"\"Returns a class given qualified class name.\n\n    Args:\n        qualified_class_name (str): The qualified name of the class.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        str: Java file name containing the given qualified class.\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_java_file(qualified_class_name)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_java_compilation_unit","title":"<code>get_java_compilation_unit(file_path: str) -&gt; JCompilationUnit</code>","text":"<p>Given the path of a Java source file, returns the compilation unit object from the symbol table.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Absolute path to Java source file</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Name Type Description <code>JCompilationUnit</code> <code>JCompilationUnit</code> <p>Compilation unit object for Java source file</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_java_compilation_unit(self, file_path: str) -&gt; JCompilationUnit:\n    \"\"\"Given the path of a Java source file, returns the compilation unit object from the symbol table.\n\n    Args:\n        file_path (str): Absolute path to Java source file\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        JCompilationUnit: Compilation unit object for Java source file\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_java_compilation_unit(file_path)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_methods_in_class","title":"<code>get_methods_in_class(qualified_class_name) -&gt; Dict[str, JCallable]</code>","text":"<p>Returns a dictionary of all methods of the given class.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>qualified class name</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>Dict[str, JCallable]</code> <p>Dict[str, JCallable]: A dictionary of all constructors of the given class.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_methods_in_class(self, qualified_class_name) -&gt; Dict[str, JCallable]:\n    \"\"\"Returns a dictionary of all methods of the given class.\n\n    Args:\n        qualified_class_name (str): qualified class name\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        Dict[str, JCallable]: A dictionary of all constructors of the given class.\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_all_methods_in_class(qualified_class_name)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_constructors","title":"<code>get_constructors(qualified_class_name) -&gt; Dict[str, JCallable]</code>","text":"<p>Returns a dictionary of all constructors of the given class.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>qualified class name</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>Dict[str, JCallable]</code> <p>Dict[str, JCallable]: A dictionary of all constructors of the given class.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_constructors(self, qualified_class_name) -&gt; Dict[str, JCallable]:\n    \"\"\"Returns a dictionary of all constructors of the given class.\n\n    Args:\n        qualified_class_name (str): qualified class name\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        Dict[str, JCallable]: A dictionary of all constructors of the given class.\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_all_constructors(qualified_class_name)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_fields","title":"<code>get_fields(qualified_class_name) -&gt; List[JField]</code>","text":"<p>Returns a dictionary of all fields of the given class</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>qualified class name</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>List[JField]</code> <p>List[JField]: A list of all fields of the given class.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_fields(self, qualified_class_name) -&gt; List[JField]:\n    \"\"\"Returns a dictionary of all fields of the given class\n\n    Args:\n        qualified_class_name (str): qualified class name\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        List[JField]: A list of all fields of the given class.\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_all_fields(qualified_class_name)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_nested_classes","title":"<code>get_nested_classes(qualified_class_name) -&gt; List[JType]</code>","text":"<p>Returns a dictionary of all nested classes of the given class</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>qualified class name</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>List[JType]</code> <p>List[JType]: A list of nested classes for the given class.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_nested_classes(self, qualified_class_name) -&gt; List[JType]:\n    \"\"\"Returns a dictionary of all nested classes of the given class\n\n    Args:\n        qualified_class_name (str): qualified class name\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        List[JType]: A list of nested classes for the given class.\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_all_nested_classes(qualified_class_name)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_sub_classes","title":"<code>get_sub_classes(qualified_class_name) -&gt; Dict[str, JType]</code>","text":"<p>Returns a dictionary of all sub-classes of the given class</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>qualified class name</p> required <p>Returns:</p> Type Description <code>Dict[str, JType]</code> <p>Dict[str, JType]: A dictionary of all sub-classes of the given class, and class details</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_sub_classes(self, qualified_class_name) -&gt; Dict[str, JType]:\n    \"\"\"Returns a dictionary of all sub-classes of the given class\n\n    Args:\n        qualified_class_name (str): qualified class name\n\n    Returns:\n        Dict[str, JType]: A dictionary of all sub-classes of the given class, and class details\n    \"\"\"\n    return self.backend.get_all_sub_classes(qualified_class_name=qualified_class_name)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_extended_classes","title":"<code>get_extended_classes(qualified_class_name) -&gt; List[str]</code>","text":"<p>Returns a list of all extended classes for the given class. Args:     qualified_class_name (str): The qualified name of the class.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of extended classes for the given class.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_extended_classes(self, qualified_class_name) -&gt; List[str]:\n    \"\"\"Returns a list of all extended classes for the given class.\n    Args:\n        qualified_class_name (str): The qualified name of the class.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        List[str]: A list of extended classes for the given class.\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_extended_classes(qualified_class_name)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_implemented_interfaces","title":"<code>get_implemented_interfaces(qualified_class_name: str) -&gt; List[str]</code>","text":"<p>Returns a list of all implemented interfaces for the given class.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>The qualified name of the class.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of implemented interfaces for the given class.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_implemented_interfaces(self, qualified_class_name: str) -&gt; List[str]:\n    \"\"\"Returns a list of all implemented interfaces for the given class.\n\n    Args:\n        qualified_class_name (str): The qualified name of the class.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        List[str]: A list of implemented interfaces for the given class.\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_implemented_interfaces(qualified_class_name)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.__get_class_call_graph_using_symbol_table","title":"<code>__get_class_call_graph_using_symbol_table(qualified_class_name: str, method_signature: str | None = None) -&gt; List[Tuple[JMethodDetail, JMethodDetail]]</code>","text":"<p>A call graph using symbol table for a given class and a given method.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>The qualified name of the class.</p> required <code>method_signature</code> <code>str | None</code> <p>The signature of the method in the class.. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>List[Tuple[JMethodDetail, JMethodDetail]]</code> <p>List[Tuple[JMethodDetail, JMethodDetail]]: An edge list of the call graph for the given class and method.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def __get_class_call_graph_using_symbol_table(self, qualified_class_name: str, method_signature: str | None = None) -&gt; (List)[Tuple[JMethodDetail, JMethodDetail]]:\n    \"\"\"A call graph using symbol table for a given class and a given method.\n\n    Args:\n        qualified_class_name (str): The qualified name of the class.\n        method_signature (str | None, optional): The signature of the method in the class.. Defaults to None.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        List[Tuple[JMethodDetail, JMethodDetail]]: An edge list of the call graph for the given class and method.\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_class_call_graph_using_symbol_table(qualified_class_name, method_signature)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_class_call_graph","title":"<code>get_class_call_graph(qualified_class_name: str, method_signature: str | None = None, using_symbol_table: bool = False) -&gt; List[Tuple[JMethodDetail, JMethodDetail]]</code>","text":"<p>A call graph for a given class and (optionally) a given method.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>The qualified name of the class.</p> required <code>method_signature</code> <code>str | None</code> <p>The signature of the method in the class.. Defaults to None.</p> <code>None</code> <code>using_symbol_table</code> <code>bool</code> <p>Generate call graph using symbol table. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>List[Tuple[JMethodDetail, JMethodDetail]]</code> <p>List[Tuple[JMethodDetail, JMethodDetail]]: An edge list of the call graph for the given class and method.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_class_call_graph(self, qualified_class_name: str, method_signature: str | None = None, using_symbol_table: bool = False) -&gt; List[Tuple[JMethodDetail, JMethodDetail]]:\n    \"\"\"A call graph for a given class and (optionally) a given method.\n\n    Args:\n        qualified_class_name (str): The qualified name of the class.\n        method_signature (str | None, optional): The signature of the method in the class.. Defaults to None.\n        using_symbol_table (bool, optional): Generate call graph using symbol table. Defaults to False.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        List[Tuple[JMethodDetail, JMethodDetail]]: An edge list of the call graph for the given class and method.\n    \"\"\"\n    if using_symbol_table:\n        return self.__get_class_call_graph_using_symbol_table(qualified_class_name=qualified_class_name, method_signature=method_signature)\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_class_call_graph(qualified_class_name, method_signature)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_entry_point_classes","title":"<code>get_entry_point_classes() -&gt; Dict[str, JType]</code>","text":"<p>Returns a dictionary of all entry point classes in the Java code.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>Dict[str, JType]</code> <p>Dict[str, JType]: A dict of all entry point classes in the Java code, with qualified class names as keys</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_entry_point_classes(self) -&gt; Dict[str, JType]:\n    \"\"\"Returns a dictionary of all entry point classes in the Java code.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        Dict[str, JType]: A dict of all entry point classes in the Java code, with qualified class names as keys\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_all_entry_point_classes()\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_entry_point_methods","title":"<code>get_entry_point_methods() -&gt; Dict[str, Dict[str, JCallable]]</code>","text":"<p>Returns a dictionary of all entry point methods in the Java code with qualified class name as key and dictionary of methods in that class as value</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, JCallable]]</code> <p>Dict[str, Dict[str, JCallable]]: A dictionary of dictionaries of entry point methods in the Java code.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_entry_point_methods(self) -&gt; Dict[str, Dict[str, JCallable]]:\n    \"\"\"Returns a dictionary of all entry point methods in the Java code with qualified class name as key and dictionary of methods in that class as value\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        Dict[str, Dict[str, JCallable]]: A dictionary of dictionaries of entry point methods in the Java code.\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_all_entry_point_methods()\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.remove_all_comments","title":"<code>remove_all_comments() -&gt; str</code>","text":"<p>Remove all comments from the source code.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The source code with all comments removed.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def remove_all_comments(self) -&gt; str:\n    \"\"\"Remove all comments from the source code.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        str: The source code with all comments removed.\n    \"\"\"\n    # Remove any prefix comments/content before the package declaration\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.CODEANALYZER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.remove_all_comments(self.source_code)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_methods_with_annotations","title":"<code>get_methods_with_annotations(annotations: List[str]) -&gt; Dict[str, List[Dict]]</code>","text":"<p>Returns a dictionary of method names and method bodies.</p> <p>Parameters:</p> Name Type Description Default <code>annotations</code> <code>List[str]</code> <p>List of annotation strings.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>Dict[str, List[Dict]]</code> <p>Dict[str, List[Dict]]: Dictionary with annotations as keys and a list of dictionaries containing method names and bodies, as values.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_methods_with_annotations(self, annotations: List[str]) -&gt; Dict[str, List[Dict]]:\n    \"\"\"Returns a dictionary of method names and method bodies.\n\n    Args:\n        annotations (List[str]): List of annotation strings.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        Dict[str, List[Dict]]: Dictionary with annotations as keys and a list of dictionaries containing method names and bodies, as values.\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.CODEANALYZER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_methods_with_annotations(self.source_code, annotations)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_test_methods","title":"<code>get_test_methods() -&gt; Dict[str, str]</code>","text":"<p>Returns a dictionary of method names and method bodies.</p> <p>Parameters:</p> Name Type Description Default <code>source_class_code</code> <code>str</code> <p>String containing code for a java class.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: Dictionary of method names and method bodies.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_test_methods(self) -&gt; Dict[str, str]:\n    \"\"\"Returns a dictionary of method names and method bodies.\n\n    Args:\n        source_class_code (str): String containing code for a java class.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        Dict[str, str]: Dictionary of method names and method bodies.\n    \"\"\"\n\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.CODEANALYZER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_test_methods(self.source_code)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_calling_lines","title":"<code>get_calling_lines(target_method_name: str) -&gt; List[int]</code>","text":"<p>Returns a list of line numbers in source method block where target method is called.</p> <p>Parameters:</p> Name Type Description Default <code>target_method_name</code> <code>str</code> <p>target method  name.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: List of line numbers within in source method code block.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_calling_lines(self, target_method_name: str) -&gt; List[int]:\n    \"\"\"Returns a list of line numbers in source method block where target method is called.\n\n    Args:\n        target_method_name (str): target method  name.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        List[int]: List of line numbers within in source method code block.\n    \"\"\"\n\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_calling_lines(self.source_code, target_method_name)\n</code></pre>"},{"location":"api_reference/#cldk.analysis.java.JavaAnalysis.get_call_targets","title":"<code>get_call_targets(declared_methods: dict) -&gt; Set[str]</code>","text":"<p>Uses simple name resolution for finding the call targets. Nothing sophiscticed here. Just a simple search over the AST.</p> <p>Parameters:</p> Name Type Description Default <code>declared_methods</code> <code>dict</code> <p>A dictionary of all declared methods in the class.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised when current AnalysisEngine does not support this function.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: A list of call targets (methods).</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_call_targets(self, declared_methods: dict) -&gt; Set[str]:\n    \"\"\"Uses simple name resolution for finding the call targets. Nothing sophiscticed here. Just a simple search over the AST.\n\n    Args:\n        declared_methods (dict): A dictionary of all declared methods in the class.\n\n    Raises:\n        NotImplementedError: Raised when current AnalysisEngine does not support this function.\n\n    Returns:\n        Set[str]: A list of call targets (methods).\n    \"\"\"\n    if self.analysis_backend in [AnalysisEngine.CODEQL, AnalysisEngine.TREESITTER]:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_call_targets(self.source_code, declared_methods)\n</code></pre>"},{"location":"contribute/","title":"Contributing to Codellm-DevKit","text":"<p>You can report issues or open a pull request (PR) to suggest changes. </p>"},{"location":"contribute/#reporting-an-issue","title":"Reporting an issue","text":"<p>To report an issue, or to suggest an idea for a change that you haven't had time to write-up yet: 1.  Review existing issues to see if a similar issue has been opened or discussed. 2.  Open an issue. Be sure to include any helpful information, such as your Kubernetes environment details, error messages, or logs that you might have.</p>"},{"location":"contribute/#suggesting-a-change","title":"Suggesting a change","text":"<p>To suggest a change to this repository, submit a pull request with the complete set of changes that you want to suggest. Before creating a PR, make sure that your changes pass all of the tests.</p> <p>The test suite can be executed with the following command in the top-level folder:</p> <pre><code>pytest\n</code></pre> <p>Also, please make sure that your changes pass static checks such as code styles by executing the following command:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"publications/","title":"Publications","text":""},{"location":"publications/#publication-papers-and-blogs-related-to-cldk","title":"Publication (papers and blogs related to CLDK)","text":"<ol> <li>Krishna, Rahul, Rangeet Pan, Raju Pavuluri, Srikanth Tamilselvam, Maja Vukovic, and Saurabh Sinha. \"Codellm-Devkit: A Framework for Contextualizing Code LLMs with Program Analysis Insights.\" arXiv preprint arXiv:2410.13007 (2024).</li> <li>Pan, Rangeet, Myeongsoo Kim, Rahul Krishna, Raju Pavuluri, and Saurabh Sinha. \"Multi-language Unit Test Generation using LLMs.\" arXiv preprint arXiv:2409.03093 (2024).</li> <li>Pan, Rangeet, Rahul Krishna, Raju Pavuluri, Saurabh Sinha, and Maja Vukovic., \"Simplify your Code LLM solutions using CodeLLM Dev Kit (CLDK).\", Blog.</li> </ol>"},{"location":"walkthrough/","title":"Walkthrough","text":""},{"location":"walkthrough/#quick-start-example-walkthrough","title":"Quick Start: Example Walkthrough","text":"<p>In this section, we will walk through a simple example to demonstrate how to use CLDK. We will:</p> <ul> <li>Set up a local ollama server to interact with CodeLLMs</li> <li>Build a simple code summarization pipeline for a Java and a Python application.</li> </ul>"},{"location":"walkthrough/#prerequisites","title":"Prerequisites","text":"<p>Before we begin, make sure you have the following prerequisites installed:</p> <ul> <li>Python 3.11 or later</li> <li>Ollama v0.3.4 or later</li> </ul>"},{"location":"walkthrough/#step-1-set-up-an-ollama-server","title":"Step 1:  Set up an Ollama server","text":"<p>If don't already have ollama, please download and install it from here: Ollama. </p> <p>Once you have ollama, start the server and make sure it is running.</p> <p>If you're on MacOS, Linux, or WSL, you can check to make sure the server is running by running the following command:</p> <pre><code>sudo systemctl status ollama\n</code></pre> <p>You should see an output similar to the following:</p> <pre><code>\u279c sudo systemctl status ollama\n\u25cf ollama.service - Ollama Service\n     Loaded: loaded (/etc/systemd/system/ollama.service; enabled; preset: enabled)\n     Active: active (running) since Sat 2024-08-10 20:39:56 EDT; 17s ago\n   Main PID: 23069 (ollama)\n      Tasks: 19 (limit: 76802)\n     Memory: 1.2G (peak: 1.2G)\n        CPU: 6.745s\n     CGroup: /system.slice/ollama.service\n             \u2514\u250023069 /usr/local/bin/ollama serve\n</code></pre> <p>If not, you may have to start the server manually. You can do this by running the following command:</p> <pre><code>sudo systemctl start ollama\n</code></pre>"},{"location":"walkthrough/#pull-the-latest-version-of-granite-8b-instruct-model-from-ollama","title":"Pull the latest version of Granite 8b instruct model from ollama","text":"<p>To pull the latest version of the Granite 8b instruct model from ollama, run the following command:</p> <pre><code>ollama pull granite-code:8b-instruct\n</code></pre> <p>Check to make sure the model was successfully pulled by running the following command:</p> <pre><code>ollama run granite-code:8b-instruct 'Write a function to print hello world in python'\n</code></pre> <p>The output should be similar to the following:</p> <pre><code>\u279c ollama run granite-code:8b-instruct 'Write a function to print hello world in python'\n\ndef say_hello():\n    print(\"Hello World!\")\n</code></pre>"},{"location":"walkthrough/#step-2-install-cldk","title":"Step 2:  Install CLDK","text":"<p>You may install the latest version of CLDK from PyPi:</p> <pre><code>pip install cldk\n</code></pre> <p>Once CLDK is installed, you can import it into your Python code:</p> <pre><code>from cldk import CLDK\n</code></pre>"},{"location":"walkthrough/#step-3-build-a-code-summarization-pipeline","title":"Step 3:  Build a code summarization pipeline","text":"<p>Now that we have set up the ollama server and installed CLDK, we can build a simple code summarization pipeline for a Java application.</p> <ol> <li> <p>Let's download a sample Java (apache-commons-cli):</p> <ul> <li>Download and unzip the sample Java application:     <code>bash     wget https://github.com/apache/commons-cli/archive/refs/tags/rel/commons-cli-1.7.0.zip -O commons-cli-1.7.0.zip &amp;&amp; unzip commons-cli-1.7.0.zip</code></li> <li>Record the path to the sample Java application:     <code>bash     export JAVA_APP_PATH=/path/to/commons-cli-1.7.0</code></li> </ul> </li> </ol> <p>Below is a simple code summarization pipeline for a Java application using CLDK. It does the following things:</p> <ul> <li>Creates a new instance of the CLDK class (see comment <code># (1)</code>)</li> <li>Creates an analysis object over the Java application (see comment <code># (2)</code>)</li> <li>Iterates over all the files in the project (see comment <code># (3)</code>)</li> <li>Iterates over all the classes in the file (see comment <code># (4)</code>)</li> <li>Iterates over all the methods in the class (see comment <code># (5)</code>)</li> <li>Gets the code body of the method (see comment <code># (6)</code>)</li> <li>Initializes the treesitter utils for the class file content (see comment <code># (7)</code>)</li> <li>Sanitizes the class for analysis (see comment <code># (8)</code>)</li> <li>Formats the instruction for the given focal method and class (see comment <code># (9)</code>)</li> <li>Prompts the local model on Ollama (see comment <code># (10)</code>)</li> <li>Prints the instruction and LLM output (see comment <code># (11)</code>)</li> </ul> <pre><code># code_summarization_for_java.py\n\nfrom cldk import CLDK\n\n\ndef format_inst(code, focal_method, focal_class):\n    \"\"\"\n    Format the instruction for the given focal method and class.\n    \"\"\"\n    inst = f\"Question: Can you write a brief summary for the method `{focal_method}` in the class `{focal_class}` below?\\n\"\n\n    inst += \"\\n\"\n    inst += f\"```{language}\\n\"\n    inst += code\n    inst += \"```\" if code.endswith(\"\\n\") else \"\\n```\"\n    inst += \"\\n\"\n    return inst\n\ndef prompt_ollama(message: str, model_id: str = \"granite-code:8b-instruct\") -&gt; str:\n    \"\"\"Prompt local model on Ollama\"\"\"\n    response_object = ollama.generate(model=model_id, prompt=message)\n    return response_object[\"response\"]\n\n\nif __name__ == \"__main__\":\n    # (1) Create a new instance of the CLDK class\n    cldk = CLDK(language=\"java\")\n\n    # (2) Create an analysis object over the java application\n    analysis = cldk.analysis(project_path=os.getenv(\"JAVA_APP_PATH\"))\n\n    # (3) Iterate over all the files in the project\n    for file_path, class_file in analysis.get_symbol_table().items():\n        class_file_path = Path(file_path).absolute().resolve()\n        # (4) Iterate over all the classes in the file\n        for type_name, type_declaration in class_file.type_declarations.items():\n            # (5) Iterate over all the methods in the class\n            for method in type_declaration.callable_declarations.values():\n\n                # (6) Get code body of the method\n                code_body = class_file_path.read_text()\n\n                # (7) Initialize the treesitter utils for the class file content\n                tree_sitter_utils = cldk.tree_sitter_utils(source_code=code_body)\n\n                # (8) Sanitize the class for analysis\n                sanitized_class = tree_sitter_utils.sanitize_focal_class(method.declaration)\n\n                # (9) Format the instruction for the given focal method and class\n                instruction = format_inst(\n                    code=sanitized_class,\n                    focal_method=method.declaration,\n                    focal_class=type_name,\n                )\n\n                # (10) Prompt the local model on Ollama\n                llm_output = prompt_ollama(\n                    message=instruction,\n                    model_id=\"granite-code:20b-instruct\",\n                )\n\n                # (11) Print the instruction and LLM output\n                print(f\"Instruction:\\n{instruction}\")\n                print(f\"LLM Output:\\n{llm_output}\")\n</code></pre>"}]}